program grayScale; type  DataType = packed array[0..100, 0..100] of Real; const  ScreenHorz = 300;  ScreenVert = 300; var  DataMax, DataMin : Real;  DataHorz, DataVert : integer;  Data : DataType;  block : Rect;  Back : Pattern; procedure ReadData;  var   i : integer; begin  close(input);  Reset(input, 'Jim:Stream_000');  DataMax := 0;  DataMin := 9999;  DataVert := 0;  while (not Eof) and (DataVert < 80) do   begin    DataHorz := 0;    while (not Eoln) and (DataHorz < 80) do     begin      Read(data[DataHorz, DataVert]);      if (DataMin > data[DataHorz, DataVert]) and (0 <> data[DataHorz, DataVert]) then       DataMin := data[DataHorz, DataVert];      if DataMax < data[DataHorz, DataVert] then       DataMax := data[DataHorz, DataVert];      dataHorz := DataHorz + 1;     end;    readln;    dataVert := DataVert + 1;   end;  dataVert := DataVert - 1;  dataHorz := DataHorz - 1;  close(input);  reset(input, 'KEYBOARD:'); end; procedure DrawData (Data : DataType);  var   x, y : integer;  procedure Drawgray (X, Y : Integer;          Data : Real);   var    grayScale : Pattern;    Block : Rect;  begin   SetRect(Block, X, Y, X + trunc(ScreenHorz / DataHorz), Y + trunc(ScreenVert / DataVert));   case trunc((Data - DataMin) / (DataMax - DataMin) * 12) of    0, 1, 2 :      grayScale := white;    3 :      grayScale := LtGray;    4 :      grayScale := Gray;    5, 6 :      grayScale := dkGray;    otherwise     if trunc((Data - DataMin) / (DataMax - DataMin) * 5) < 0 then      grayScale := Back     else      grayScale := Black;   end;   fillRect(Block, grayScale);  end; begin  for X := 0 to DataHorz do   for Y := 0 to DataVert do    Drawgray(trunc(X * (ScreenHorz / DataHorz)), trunc(Y * (ScreenVert / DataVert)), data[x, y]) end;begin setRect(Block, 0, 0, ScreenHorz, ScreenVert); back[0] := 1; Back[1] := 2; Back[2] := 4; back[3] := 8; Back[4] := 16; Back[5] := 32; Back[6] := 64; Back[7] := 128; fillRect(Block, Back); ReadData; DrawData(data);end.