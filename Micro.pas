program Micro;  	{$B+}  	{$T APPL MICR}	{$L MicroRsrc}	{$I TML:Library:MemTypes.ipas}	{$I TML:Library:QuickDraw.ipas}	{$I TML:Library:OSIntf.ipas}	{$I TML:Library:ToolIntf.ipas}	{$I TML:Library:PackIntf.ipas}	{$I TML:Library:ListMgrIntf.ipas}	{$I TML:Library:FileIo.iPas}	{$I TML:Library:Serial.iPas}	type		{My Types}		arr4=array[1..4] of real; 		HeaderType= 			packed record 				Filename:str255; 				NumParticle:Integer; 				Event:str255; 				Date:str255; 				operator:str255; 				ShrinkFactZT:Real; 				ShrinkFactZM:Real; 				Magnification:Real; 				ZZO:Real; 				X:arr4; 				y:arr4; 				z:arr4; 				ShrinkFactAN:Real; 				dipofprimary:real; 			end; 		ParticleType= 			packed record 				Number:Str255; 				theta:real; 				ZScaleDiv:Real; 				Ymicrons:real; 				GrainCount:real; 				P:Real; 				L:real; 				Fate:str255;				beta:real;					{beta}				degrees:real;				{beta expressed in degrees}				azimuth:real;				{azimuth angle}				azidegree:real;			{azimuth angle expressed in degress}				pseudo:real;				{pseudoripidity}				dip:real;						{slope of children particles with respect to the primary}				x:real;						{the value calculated from the raw data}				y:real;						{the value calculated from the raw data}				z:real;						{the value calculated from the raw data}			end;		TrickType =			packed record				case boolean of					true :						(I : LongInt);					false :						(chr3, chr2, chr1, chr0 : Char);				end;		{Real To String Types}		charKind = 			( digit, a_sign, decimalPoint, space, an_E, other);		State    = 			( start, sign, mantissa, period, fraction, s_notation,s_sign, s_digit, error, finish);	const		HeaderRes=			6000;		ParticleRes=			6001;		DebugRes=			6002;		AreSureRes=			6003;		AboutRes=			6004;		appleMenu = 			300;		fileMenu = 			301;		editMenu = 			302;		particleMenu = 			303;		HeaderMenu = 			304;		beginMenu = 			300;		endMenu = 			304;		pi=			3.1415926535898;		DecAcc=			5;	var		{Mac Varibles}				Done:			Boolean;		myMenus:			 array[beginMenu..endMenu] of MenuHandle;		DragArea,		GrowArea:			Rect;		{My Global Varibles}				InMem,		FromFile,		changed:			Boolean;							ParticleCount:			Integer;					Header:			HeaderType;		List:			ListHandle;		ListWindow:			WindowPtr;		{RealtoString Vars}		stateTable:			array [start..finish, digit..other] of state;		stateNow:			state;	procedure CalcHeader(var Header:HeaderType);		{calculates the dip of the primary}		var			n:integer;			{the # of points at which the primary was measured}			j:integer;			{j will be the array indice counter throughout}			partialdip:real;	{partial sum of dip}		begin {primary}			partialdip:=0;			{at how many points was the primary measured};			{send in each x,y,z cooridinate}			if (header.x[4]=0) and (header.y[4]=0) and (header.z[4]=0) then				n:=3			else n:=4;				for j:=n downto 2 do					partialdip:= ((header.z[j]-header.z[j-1])/(header.y[j]-header.y[j-1]))+partialdip;			if Header.ShrinkFactZM<>0 then				Header.ShrinkFactAN:=Header.ShrinkFactZT/Header.ShrinkFactZM;			header.dipofprimary:= (partialdip/((n-1)*1000))*(header.shrinkFactAN);		end;{primary}	procedure CalcParticle(var Particle:ParticleType;													Header:HeaderType);		{michael heinrich}		{5/28/86}		{this program will take raw data recorded by}		{workers using optical microscopes for cosmic ray research}		{the raw data is converted into x,y,z coordinates }		procedure particleStuff;			{inputs the data for the individual particles}			{in the star and calculates their dips}			begin {particle}				with Particle do					dip:=(ZScalediv)/(ymicrons);			end;{particle}		procedure calculate;			{calculates x,y,z}			{x,y,z are 1 dimensional arrays used by research}			begin {calculate}				Particle.x:=(Particle.ymicrons)*sin((Particle.theta)*(pi/180));				Particle.y:=(Particle.ymicrons)*cos((Particle.theta)*(pi/180));				if abs(Particle.theta)<=90 then					Particle.z:=(Particle.dip-header.dipofprimary)*(Particle.ymicrons)*(header.ShrinkFactAN)				else					Particle.z:=(Particle.dip+header.dipofprimary)*(Particle.ymicrons)*(header.ShrinkFactAN);			end;{calculate}		procedure research1;   		{written by michael heinrich}   		{5/8/86}   		{this program will take data from a data file }   		{which specifies x,y,z coordinates and calculate}   		{beta,pseudoripidity,and azimuth angle}       	{this procedure reads and manipulates one }       	{line of data from the dataout}			var				j:integer;			procedure calcbeta;			{calculates beta}				begin {beta}					Particle.beta:=arctan(sqrt(sqr(Particle.x)+sqr(Particle.z))/abs(Particle.y));					if abs(Particle.y)<>Particle.y then						Particle.beta:=-Particle.beta;					if Particle.y<0 then						Particle.beta:=Particle.beta+pi;					Particle.degrees:=Particle.beta*180/pi				end;{beta}			procedure psuedoripidity;				{calculates pseudoripidity}				begin {psuedoripidity}					Particle.pseudo:=-ln(abs(sin(Particle.beta/2)/cos(Particle.beta/2)));				end;{psuedoripidity}			procedure azimuthangle;				{calculates azimuth angle}				begin {azimuthangle}					if Particle.z=0 then						Particle.azimuth:=(pi/2)					else						begin         {z<>0}							Particle.azimuth:=arctan(abs(Particle.x/Particle.z));							{computer won't take - values in function}							if abs(Particle.x/Particle.z)<>(Particle.x/Particle.z) then								Particle.azimuth:=-Particle.azimuth;							{corrected for - values}						end;					{now implement Dr. Frier's sign convention}					if Particle.z < 0 then							{z < 0}							Particle.azimuth:=Particle.azimuth+pi					else    {z >= 0}						begin							if Particle.x<0 then								{z >= 0 and x < 0}								Particle.azimuth:=Particle.azimuth+2*pi;						end;					Particle.azidegree:=Particle.azimuth*180/pi;			end;{azimuthangle}			begin {research}				calcbeta;				psuedoripidity;				azimuthangle;			end;{research}		begin {NHmethod}			particleStuff;			calculate;			research1;		end;	procedure makeStateTable;  var     st : state;  begin  {*                         STATE TABLE                                *}  {*                                                                    *}  {*             digit     a_sign   point     space   an_E       other  *}  {* ------------------------------------------------------------------ *}  {* start       mantissa  sign     period    start   error       error *}  {* sign        mantissa  error    period    error   error       error *}  {* mantissa    mantissa  error    period    finish  s_notation  error *}  {* period      fraction  error    error     error   error       error *]  {* fraction    fraction  error    error     finish  s_notation  error *}  {* s_notation  s_digit   s_sign   error     error   error       error *}  {* s_sign      s_digit   error    error     error   error       error *}  {* s_digit     s_digit   error    error     finish  error       error *}  {* finish      error     error    error     finish  error       error *}    {**** digit }    for st := start to mantissa do      stateTable [ st, digit ] := mantissa;    for st := period to fraction do      stateTable [ st, digit ] := fraction;    for st := s_notation to s_digit do      stateTable [ st, digit ] := s_digit;    stateTable [finish, digit] := error;    {**** a_sign }    stateTable [start, a_sign] := sign;    for st := sign to fraction do      stateTable [ st, a_sign ] := error;    stateTable [s_notation, a_sign] := s_sign;    for st := s_sign to finish do      stateTable [ st, a_sign ] := error;    {**** decimalPoint }    for st := start to mantissa do      stateTable [ st, decimalPoint ] := period;    for st := period to finish do      stateTable [ st, decimalPoint ] := error;    {**** space }    stateTable [start, space] := start;    stateTable [sign, space] := error;    stateTable [mantissa, space] := finish;    stateTable [period, space] := error;    stateTable [fraction, space ] := finish;    for st := s_notation to s_sign do      stateTable [ st, space ] := error;    for st := s_digit to finish do      stateTable [ st, space ] := finish;    {**** an_E }    for st := start to sign do      stateTable [ st, an_E ] := error;    stateTable [ mantissa, an_E ] := s_notation;    stateTable [ period, an_E ] := error;    stateTable [ fraction, an_E ] := s_notation;    for st := s_notation to finish do      stateTable [ st, an_E ] := error;    {**** other }    for st := start to finish do      stateTable [ st, other ] := error;  end; {makeStateTable} 	procedure realToString (realNum : real; var outputString : str255);{convert a real number to a string}  const      maxDigit      = 20;  var      exp           : char;      i, j,      expLength,      beforeDecimal : integer;      r,      temp          : real;      tempString    : str255;      ScientificNotation : boolean;  procedure PositiveExp (var r : real; var length : integer);    begin      length := 0;      {count the number of digits before decimal point}      while r >= 10.0 do      begin	  r := r/10.0;	  length := length + 1;      end;    end; {PositiveExp}  function NegativeExp (var r : real; var length: integer) : boolean;    const      digAfterDecimal = 5;    var      temp : real;    begin      temp := r;      length := 0;      if r <> 0 then          {count the number of leading zeros for a number less than zero}	  while r < 1 do	  begin	    r := r * 10;	    length := length + 1;	  end;      if length > digAfterDecimal then          NegativeExp := true {use exponent to present the small real number}      else      begin          NegativeExp := false;	  r := temp;      end;    end; {NegativeExp}  begin {realToString}     r := abs(realNum);     if NegativeExp (r, expLength) then     begin         beforeDecimal := 1;	 ScientificNotation := true;         exp := '-';     end     else     begin        PositiveExp (r, expLength);	if expLength  >= maxDigit - 2 then	begin           beforeDecimal := 1;	   ScientificNotation := true;	   exp := '+';	end	else	begin	    beforeDecimal := expLength + 1; {use exponent to present the big real number}	    ScientificNotation := false;	end;     end; {else}     {fix the real number convertion error}     temp := 1.0;     for i := 1 to 18 do         temp := temp * 10.0;     r :=  r + 0.5  / temp;     {fix convertion error}     if trunc(r) = 10 then     begin         r := 1.0;	 expLength := expLength - 1;     end;     {convert the numbers before decimal point to the string }     for i := 1 to beforeDecimal do     begin	 outputString[i] := chr (trunc (r) + ord('0'));	 r := (r - trunc (r)) * 10.0;     end;     outputString [beforeDecimal +1] := '.';     {convert the numbers after decimal point to the string }     for i := (beforeDecimal+2) to maxDigit do     begin	 outputString[i] := chr ( trunc (r) + ord('0') );	 r := (r - trunc (r)) * 10.0;     end;     if ScientificNotation then     {use exponent to present the real number}     begin	 outputString[maxDigit+1] := 'E';	 outputString[maxDigit+2] := exp;	 numToString (expLength, tempString);	 insert(tempString,outputString,maxDigit+3);     end;     if realNum < 0 then {negative real number}     begin         tempString := '-';	 insert(tempString,outputString,1);     end;  end; {realToString}	procedure stringToReal (inputString : str255; var realNum : real);{converts a string to a real number}  var    extended       : longInt;    prevState      : state;    man,    frac,    place,    characteristic : real;    i,    width,    integer_sign,    mantissaPosi   : integer;    exp            : char;  function class ( ch: char) : charKind;  { classify the character kinds }    begin      case ch of	'0','1','2','3','4','5','6','7','8','9': class := digit;	'+','-' : class := a_sign;	'.'     : class := decimalPoint;	' '     : class := space;	'E','e' : class := an_E;	otherwise class := other;      end;    end; {class}  begin {stringToReal}     stateNow       := start;     prevState      := start;     man            := 0.0;     frac           := 0.0;     place          := 1;     exp            := '+';     integer_sign   := 1;     extended       := 0;     mantissaPosi   := 0;     exp := '+';     realNum := 0;     i     := 1;     width := length (inputString);     {check and convert each character in the string}     while (i<= width) and (stateNow <> error) do     begin         prevState := stateNow;         stateNow := stateTable [stateNow, class (inputString[i])];	 case stateNow of	   sign     : if inputString[i] = '-' then integer_sign := -1;	   mantissa :	            begin		        man := man * 10 + ord (inputString[i]) - ord ('0');			mantissaPosi := mantissaPosi + 1;		    end;	   fraction :		    begin		      frac := frac * 10 + ord (inputString[i]) - ord ('0');		      place := place * 10;		    end;	    s_sign  : if inputString[i] = '-' then exp := '-';	    s_digit : extended := extended * 10 + ord (inputString[i]) - ord ('0');	    otherwise;	 end; {case}	 i := i + 1;     end; {while}     if (stateNow = sign) or (stateNow = s_sign) or (stateNow = s_notation) or        ((stateNow = period) and (prevState = start)) then	    stateNow := error;     if (extended + mantissaPosi - 1) > maxInt then         stateNow := error;     if (stateNow <> error) and (stateNow <> start) then     begin       characteristic := 1;       for i := 1 to extended do	   characteristic := characteristic * 10;       if exp = '+' then	    realNum := integer_sign * (man + frac/place) * characteristic       else	    realNum := integer_sign * (man + frac/place) / characteristic;     end;  end; {stringToReal}  {************************}	procedure MyListDef(		lMessage :			 Integer;		lSelect :			 Boolean;		lRect :			Rect;		lCell : 			Cell;		lDataOffSet : 			Integer;		lDataLen : 			Integer;		lHandle : 			ListHandle);		procedure DoDrawMsg(SelectIt : boolean;				theRect : Rect;				theCell : Cell;				theHandle : ListHandle);			begin				EraseRect(theRect);				InsetRect(TheRect,1,1);				frameRect(TheRect);				InsetRect(TheRect,-1,-1);				if SelectIt then					invertRect(theRect);			end;		begin			case lMessage of				lInitMsg:;				lDrawMsg:DoDrawMsg(lSelect,lRect,lCell,lHandle);				lHiliteMsg:invertRect(lRect);				lCloseMsg:;			end;		end;{*************************}	function Power (Base, Expo : real) : Real;		begin			if Base = 0 then				Power := 0			else				power := exp(expo * ln(Base));		end;	Procedure RealToString1 (WholeNumber : Real;										TheString : Str255);		var			integerPart, decimalPart : str255;		begin			numToString(trunc(wholeNumber), IntegerPart);			numToString(round((wholeNumber - trunc(wholeNumber)) * power(10, DecAcc)), decimalPart);			TheSTring:= concat(IntegerPart, '.', copy('000000', 1, DecAcc- length(DecimalPart)), decimalPart);		end;	Procedure StringToReal1 (WholeNumber : str255;										TheReal: real);		var			decimalPos : integer;			IntegerPart : longint;			DecimalPart : longint;			zeros : integer;		begin			DecimalPart := 0;			IntegerPart := 0;			DecimalPos := pos('.', WholeNumber);			if DecimalPos = 0 then				stringtonum(WholeNumber, IntegerPart)			else				begin					if DecimalPos <> 1 then					StringToNum(copy(WholeNumber, 1, DecimalPos - 1), integerpart);					Zeros := 0;					Delete(WholeNumber, 1, DecimalPos);					while copy(WholeNumber, 1, 1) = '0' do						begin							Delete(WholeNumber, 1, 1);							Zeros := Zeros + 1;						end;					wholeNumber:=copy(WholeNumber,1,DecAcc);					StringToNum(WholeNumber, DecimalPart);				end;			TheReal:= IntegerPart + DecimalPart / Power(10, zeros + Length(WholeNumber));		end;{*************************}	procedure CleanParticle(var Particle:ParticleType);			begin			with Particle do				begin					number:=' ';					theta:=0; 					ZScaleDiv:=0; 					Ymicrons:=0; 					GrainCount:=0; 					P:=0; 					L:=0; 					Fate:=' ';					beta:=0;					pseudo:=0;					azimuth:=0;					degrees:=0;					azidegree:=0;					dip:=0;					x:=0;					y:=0;					z:=0;				end;		end;     procedure AddParticle(	Particle				:ParticleType);		var			Last:Cell;			Dummy:Integer;			aBol:Boolean;		begin			Dummy:=LAddRow(1,ParticleCount,List);			particlecount:=particlecount+1;			Last.h:=0;			Last.v:=ParticleCount;			LSetCell(pointer(ord(@Particle)),SizeOf(Particle),Last,List);			LSetSelect(true,Last,List);		end;		     procedure DeleteParticle(var NoSelect:Boolean);		var			last:Cell;		begin			NoSelect:=False;			if LGetSelect(true,Last,List) then				LDelRow(1,Last.v,List)			else				NoSelect:=True;		end;     procedure GetParticle(	var Particle				:ParticleType;     											var NoSelect:Boolean);		var			Last:Cell;			len:Integer;		begin			NoSelect:=False;			Last:=LLastClick(List);			len:=SizeOf(Particle);			if last.v >= 0 then				LGetCell(pointer(ord(@Particle)),Len,Last,List)			else				NoSelect:=true;		end;		     procedure SetParticle(	Particle:ParticleType;     										var NoSelect:Boolean);		var			Last:Cell;			Dummy:Integer;		begin			NoSelect:=False;			Last:=LLastClick(List);			if last.v >= 0 then				LSetCell(pointer(ord(@Particle)),SizeOf(Particle),Last,List)			else				NoSelect:=true;		end;{******************************}	procedure CleanHeader;		var			i:integer;		begin			with Header do				begin					Event:=''; 					Date:=''; 					operator:=''; 					ZZO:=0; 					ShrinkFactZT:=0; 					ShrinkFactZM:=0; 					Magnification:=0; 					for i:=1 to 4 do 						begin 							X[i]:=0.0; 							y[i]:=0.0; 							z[i]:=0.0; 						end;					dipofprimary:=0; 					ShrinkFactAN:=0;				end;		end;{*****************************}	Procedure SetDlgStr(	DialogPointer	:DialogPtr;										Item				:integer;										TheString		:str255);		var			ItemType		:integer;			TextHandle		:Handle;			Box					:rect;		begin			GetDItem(DialogPointer,Item,ItemType,TextHandle,Box);			SetItext(TextHandle,TheString);		end;	procedure SetReal(	DialogPointer		:DialogPtr;										Item					:integer;										TheReal				:real);		var			ItemType		:integer;			TextHandle		:Handle;			Box					:rect;			TheString		:str255;		begin			GetDItem(DialogPointer,item,ItemType,TextHandle,Box);			RealToString(TheReal,TheString);			SetItext(TextHandle,TheString);		end;	function GetDlgStr(	DialogPointer	:DialogPtr;										Item				:integer):str255;		var			ItemType		:integer;			TextHandle		:Handle;			Box					:rect;			TheString		:str255;		begin			GetDItem(DialogPointer,Item,ItemType,TextHandle,Box);			GetItext(TextHandle,TheString);			GetDlgStr:=TheString;		end;	function GetReal(	DialogPointer		:DialogPtr;									Item					:integer):Real;		var			ItemType		:integer;			TextHandle		:Handle;			Box					:rect;			RealString		:str255;			TheReal			:real;		begin			GetDItem(DialogPointer,item,ItemType,TextHandle,Box);			GetItext(TextHandle,RealString);			StringToReal(RealString,TheReal);			GetReal:=TheReal;		end;	procedure ReadMicro(var Chanel1,Chanel2,Chanel3:Real;						var	FootStop:Boolean);		var			TheString:str255;		procedure GetString(var TheString:str255);			var				ch:char;						begin				while InReady(SPortA) do					begin						GetChar(SPortA,ch);						thestring:=concat(thestring,ch);					end;			end;		procedure SendString(TheString:str255);			var				i:integer;							begin				for i := 1 to Length(TheString) do					sendChar(SPortA,TheString[i]);				sendChar(SPortA,chr(13));				sendChar(SPortA,chr(10));			end;					begin			getString(TheString);			if pos('S',TheString)<>0 then				FootStop:=true			else				FootStop:=False;			SendString('D1');			getString(TheString);			StringtoReal(TheString,Chanel1);			SendString('D2');			getString(TheString);			StringtoReal(TheString,Chanel2);			SendString('D3');			getString(TheString);			StringtoReal(TheString,Chanel3);		end;					Procedure Modal(	var cancel					:Boolean;									readMicroscope					:Boolean);		Var			itemHit	:integer;			Done		:boolean;		function DialogFilter (TheDialog:DialogPtr;			var Event:EventRecord;			var itemNumber:Integer)				:Boolean;			const				returnCode=36;				enterCode=52;				CancelCode=50;				var				charCode:char;				TrickVar:TrickType;				TheWindow:WindowPtr;					footstop:boolean;				chanel1,chanel2,chanel3:real;				procedure processDialogMenu(CodeWord:LongInt);							var					menuNum : Integer;					itemNum : Integer;									begin					menuNum := HiWord(CodeWord);					itemNum := LoWord(CodeWord);					if MenuNum = 3 then								case ItemNum of							1:;							2:;							3:DlgCut(TheDialog);							4:DlgCopy(TheDialog);							5:DlgPaste(TheDialog);							6:DlgDelete(TheDialog);						end;					HiliteMenu(0);				end;				begin				DialogFilter:=false;				case Event.What of					mouseDown:						if FindWindow(Event.where,theWindow)=inMenuBar then							begin								ProcessDialogMenu(MenuSelect(Event.where));								DialogFilter:=true;							end;					keyDown,AutoKey:						begin							trickVar.I := Event.Message;							CharCode:=trickVar.chr0;							if BitAnd(Event.modifiers,CmdKey) = CmdKey then								begin									processDialogMenu(MenuKey(CharCode));									DialogFilter:=true;								end;							if CharCode = chr(returnCode) then								begin									itemNumber:=OK;									DialogFilter:=true;								end;							if CharCode = chr(CancelCode) then								begin									itemNumber := 2;									DialogFilter:=true;								end;							if CharCode = chr(enterCode) then								begin									Event.message:=Event.message+6;									DialogFilter:=false;								end;							if ReadMicroscope then								begin									sysbeep(100);									ReadMicro(Chanel1,Chanel2,Chanel3,FootStop);									if FootStop then										begin											itemNumber:=OK;											DialogFilter:=true;										end;									SetReal(TheDialog,4,chanel1);									SetReal(TheDialog,5,chanel2);									SetReal(TheDialog,6,chanel3);								end;						end;				end;			end;  		begin  			cancel:=false;  			done:=false;  			  			DisableItem(MyMenus[EditMenu],1);  			DisableItem(MyMenus[EditMenu],2);  			EnableItem(MyMenus[EditMenu],3);  			EnableItem(MyMenus[EditMenu],4);  			EnableItem(MyMenus[EditMenu],5);  			EnableItem(MyMenus[EditMenu],6);  			DisableItem(myMenus[appleMenu],0);  			DisableItem(myMenus[FileMenu],0);  			DisableItem(myMenus[ParticleMenu],0);  			DisableItem(myMenus[HeaderMenu],0);  			drawMenuBar;        		repeat            		begin {repeat}               		ModalDialog(@DialogFilter,itemHit);               		case itemHit of                 			1:Done:=true;                 			2:begin                     				done:=true;                      				cancel:=true;                    			end;							otherwise;                		end;{case}              		end;{repeat}          		until done;          	EnableItem(MyMenus[EditMenu],1);  			EnableItem(MyMenus[EditMenu],2);  			EnableItem(MyMenus[EditMenu],3);  			EnableItem(MyMenus[EditMenu],4);  			EnableItem(MyMenus[EditMenu],5);  			EnableItem(MyMenus[EditMenu],6);  			EnableItem(myMenus[appleMenu],0);  			EnableItem(myMenus[FileMenu],0);  			EnableItem(myMenus[ParticleMenu],0);  			EnableItem(myMenus[HeaderMenu],0);  			drawMenuBar;    	end;{dialog}    procedure HeaderDialog(var cancel:boolean);		var			DialogPointer	:DialogPtr;			seconds:longint;			i:integer;		begin			if Header.Date = '' then				begin					getdatetime(seconds);					IUDateString(seconds,shortDate,Header.Date);				end;			if Header.Event = '' then				begin				end;			if Header.Operator = '' then				begin				end;			DialogPointer:=GetNewDialog(HeaderRes,nil,pointer(-1));			SetDlgStr(DialogPointer,3,Header.Event);			SetDlgStr(DialogPointer,4,Header.Date);			SetDlgStr(DialogPointer,5,Header.Operator);			SetReal(DialogPointer,6,Header.ShrinkFactZT);			SetReal(DialogPointer,7,Header.ShrinkFactZM);			SetReal(DialogPointer,8,Header.Magnification);			SetReal(DialogPointer,9,Header.ZZO);			for i:=1 to 4 do				begin					SetReal(DialogPointer,10+(i-1)*3,Header.X[i]);					SetReal(DialogPointer,11+(i-1)*3,Header.Y[i]);					SetReal(DialogPointer,12+(i-1)*3,Header.Z[i]);				end;			SetReal(DialogPointer,22,Header.ShrinkFactAN);			SetReal(DialogPointer,23,Header.dipofprimary);			Modal(Cancel,false);			if not cancel then				begin					Header.Event:=GetDlgStr(DialogPointer,3);					Header.Date:=GetDlgStr(DialogPointer,4);					Header.Operator:=GetDlgStr(DialogPointer,5);					Header.ShrinkFactZT:=GetReal(DialogPointer,6);					Header.ShrinkFactZM:=GetReal(DialogPointer,7);					Header.Magnification:=GetReal(DialogPointer,8);					Header.ZZO:=GetReal(DialogPointer,9);					for i:=1 to 4 do						begin							Header.X[i]:=GetReal(DialogPointer,10+(i-1)*3);							Header.Y[i]:=GetReal(DialogPointer,11+(i-1)*3);							Header.Z[i]:=GetReal(DialogPointer,12+(i-1)*3);						end;					CalcHeader(Header);				end;			CloseDialog(DialogPointer);		end;    procedure ParticleDialog(	var Particle		:ParticleType;    											var Cancel		:Boolean);		var			DialogPointer			:DialogPtr;		begin			DialogPointer:=GetNewDialog(ParticleRes,nil,pointer(-1));			SetDlgStr(DialogPointer,3,Particle.Number);			SetReal(DialogPointer,4,Particle.Theta);			SetReal(DialogPointer,5,Particle.ZScaleDiv);			SetReal(DialogPointer,6,Particle.YMicrons);			SetReal(DialogPointer,7,Particle.GrainCount);			SetReal(DialogPointer,8,Particle.P);			SetReal(DialogPointer,9,Particle.L);			SetDlgStr(DialogPointer,10,Particle.fate);			SetReal(DialogPointer,11,Particle.Beta);			SetReal(DialogPointer,12,Particle.degrees);			SetReal(DialogPointer,13,Particle.azimuth);			SetReal(DialogPointer,14,Particle.azidegree);			SetReal(DialogPointer,15,Particle.pseudo);			SetReal(DialogPointer,16,Particle.dip);			SetReal(DialogPointer,17,Particle.X);			SetReal(DialogPointer,18,Particle.Y);			SetReal(DialogPointer,19,Particle.Z);			Modal(Cancel,true);			if not cancel then				begin					Particle.Number:=GetDlgStr(DialogPointer,3);					Particle.Theta:=GetReal(DialogPointer,4);					Particle.ZScaleDiv:=GetReal(DialogPointer,5);					Particle.YMicrons:=GetReal(DialogPointer,6);					Particle.GrainCount:=GetReal(DialogPointer,7);					Particle.P:=GetReal(DialogPointer,8);					Particle.L:=GetReal(DialogPointer,9);					Particle.fate:=GetDlgStr(DialogPointer,10);					CalcParticle(particle,header);				end;			CloseDialog(DialogPointer);		end;{*******************}	procedure DebugDialog(	theString:str255;    											theReal:Real;    											TheInteger:integer);    													var			DialogPointer	:DialogPtr;			cancel:boolean;			    	begin    		DialogPointer:=GetNewDialog(DebugRes,nil,pointer(-1));    		SetDlgStr(DialogPointer,3,TheString);			SetReal(DialogPointer,4,TheReal);			NumToString(TheInteger,TheString);			SetDlgStr(DialogPointer,5,TheString);    		Modal(Cancel,false);			CloseDialog(DialogPointer);    	end;	procedure AreYouSure(	TheString	:Str255;											var cancel	:boolean);		var			DialogPointer	:DialogPtr;					begin			DialogPointer:=GetNewDialog(AreSureRes,nil,pointer(-1));			SetDlgStr(DialogPointer,3,TheString);			Modal(Cancel,false);			CloseDialog(DialogPointer);		end;{**********************}	procedure ProcessMenu(CodeWord : LongInt);		var			menuNum : Integer;			itemNum : Integer;{***********************}		procedure DoAppleMenu;			procedure About;				var					AboutRecord : DialogRecord;					AboutDlog : DialogPtr;					dummy:integer;				begin					AboutDlog := GetNewDialog(AboutRes,nil,Pointer(-1));					ModalDialog(nil,dummy);					CloseDialog(AboutDlog);				end;			procedure DeskAccesory;				var					dummy:integer;					nameHolder : str255;				begin					GetItem(myMenus[appleMenu],ItemNum,NameHolder);					dummy := OpenDeskAcc(NameHolder);				end;			begin				case ItemNum of					1:About;					2 :;					otherwise						deskAccesory;				end;			end;{*****************}		procedure DoEditMenu;			begin				if not SystemEdit(ItemNum - 1) then					begin						case ItemNum of						end;					end;			end;		procedure DoFileMenu;			{procedures for file menu}			procedure NewList;				var					CSize:Point;					DataBounds,rview:Rect;				begin					if InMem then						begin							LDispose(List);							DisposeWindow(listWindow);						end;					ListWindow:=GetNewWindow(300,nil,Pointer(-1));					SetPort(ListWindow);					Databounds.top:=0;					DataBounds.Left:=0;					DataBounds.Bottom:=0;					DataBounds.Right:=1;					Rview:=ListWindow^.PortRect;					Rview.right:=Rview.right-16;					CSize.v:=16;					CSize.h:=rview.right-rview.left;					list:=Lnew(Rview,databounds,cSize,0,Listwindow,false,false,false,true);					List^^.ListDefProc:=NewHandle(0);					List^^.ListDefProc^:=ptr(@MyListDef);					List^^.selFlags:=lOnlyOne;					LDoDraw(true,List);				end;			procedure ReadHeader;				begin				end;			procedure ReadParticles;				begin				end;			procedure GetReadFile(var Cancel:boolean);				var					pt:point;					FileType:SFTypeList;					reply:SFReply;				begin					pt.h:=50;					pt.v:=50;					FileType[0][1]:='T';					FileType[0][2]:='E';					FileType[0][3]:='X';					FileType[0][4]:='T';					SFGetFile(pt,'Enter File',nil,1,filetype,nil,reply);					cancel:=Reply.good;					if not cancel then						header.filename:=reply.fName;				end;			{the File menu procedures}			procedure NewFile;				var					cancel:boolean;				begin					cancel:=False;					if changed and InMem then						AreYouSure('Are you sure you want to throw away Changes to this file?',Cancel);					if not cancel then						begin							CleanHeader;							HeaderDialog(Cancel);							if not Cancel then								begin									Header.filename:='untitled';									Header.NumParticle:=0;									NewList;									changed:=True;									InMem:=True;								end;						end;				end;			procedure OpenFile;				var					Dialog:DialogPtr;					pt:point;					FileType:SFTypeList;					Reply:SFReply;					Cancel:Boolean;				begin					if Changed then						AreYouSure('Are you sure you want to throw away Changes to this file?',Cancel);					if not cancel then						begin							GetReadFile(Cancel);							if not cancel then								begin									ReadHeader;									ReadParticles;									Changed:=True;									InMem:=True;								end;						end;				end;			Procedure CloseFile;				begin				end;			Procedure SaveAsFile;				begin				end;			Procedure SaveFile;				begin				end;			Procedure RevertFile;				begin				end;			Procedure AppendFile;				begin				end;			Procedure PageSetUp;				begin				end;			Procedure PrintFile;				begin				end;			begin				case ItemNum of					1:NewFile;					2:OpenFile;					3:CloseFile;					4:;					5:SaveFile;					6:SaveAsFile;					7:RevertFile;					8:;					9:AppendFile;					10:;					11:PageSetUp;					12:PrintFile;					13:;					14:Done := true;				end;			end;{******************}		procedure DoParticleMenu;			procedure NewParticle(var Cancel:Boolean);				var					particle:ParticleType;									begin					CleanParticle(Particle);					ParticleDialog(Particle,cancel);					if not cancel then						begin							AddParticle(Particle);							Changed:=true;						end;				end;			procedure AddParticleMenu;				var					cancel:boolean;				begin					NewParticle(Cancel);				end;			procedure AddContinuousParticle;				var					cancel:boolean;				begin					repeat						NewParticle(Cancel);					until cancel;				end;			procedure EditParticle;				var					cancel,NoSelect:boolean;					Particle:ParticleType;				begin					GetParticle(Particle,NoSelect);					if not NoSelect then						begin							ParticleDialog(Particle,cancel);							if not cancel then								SetParticle(Particle,NoSelect);								if not NoSelect then									Changed:=true;						end;				end;			procedure ClearParticle;				var					particle:ParticleType;					NoSelect:Boolean;									begin					GetParticle(Particle,NoSelect);					if not NoSelect then						begin							CleanParticle(Particle);							SetParticle(Particle,NoSelect);							Changed:=true;						end;				end;			procedure DeleteParticleMenu;				var					noSelect:Boolean;									begin					DeleteParticle(NoSelect);					if Not NoSelect then						changed:=true;				end;			begin				case ItemNum of					1:AddParticleMenu;					2:AddContinuousParticle;					3:EditParticle;					4:ClearParticle;					5:DeleteParticleMenu;				end;			end;{****************}		procedure DoHeaderMenu;			procedure EditHeader;				var					cancel:boolean;				begin					HeaderDialog(Cancel);					if not cancel then						Changed:=true;				end;			Procedure ClearHeader;				begin					ClearHeader;					changed:=true;				end;			begin				case ItemNum of					1:EditHeader;					2:ClearHeader;				end;			end;{*****************}		begin			menuNum := HiWord(CodeWord);			itemNum := LoWord(CodeWord);			if itemNum > 0 then				begin					case MenuNum of						1:DoAppleMenu;						2:DoFileMenu;						3:DoEditMenu;						4:DoParticleMenu;						5:DoHeaderMenu;					end;				end;			HiliteMenu(0);		end;	procedure AllDone;		begin			CloseSPort(sPortA);		end;{******************}	procedure MainEventLoop;		var			Event : EventRecord;			windowLoc : integer;			mouseLoc : point;			theWindow:WindowPtr;			trickVar : trickType;			CharCode : Char;			aBool : Boolean;			totalRect : Rect;			Last:Cell;		begin			repeat				SystemTask;				Last.v:=0;				Last.h:=0;				if not LGetSelect(true,Last,List) then					begin						Last.v:=0;						Last.h:=0;						LSetSelect(True,last,List);					end;				if GetNextEvent(everyEvent,Event) then					begin						case event.what of							mouseDown :								begin									mouseLoc := Event.where;									windowLoc := FindWindow(mouseLoc,theWindow);									case windowLoc of										inMenuBar :											ProcessMenu(MenuSelect(MouseLoc));										inSysWindow:											SystemClick(Event,theWindow);										inContent:											begin												GlobalToLocal(MouseLoc);												aBool := LClick(MouseLoc, Event.modifiers,List);											end;										inDrag:											begin        										DragWindow(theWindow,mouseLoc,DragArea);												SelectWindow(theWindow);      										end;      									inGrow:      										begin      											GlobalToLocal(MouseLoc);												aBool := LClick(MouseLoc, Event.modifiers,List);      										end;      									inGoAway:      										begin      										end;      									inDesk:      										Begin      										end;									end;								end;							UpdateEvt :								begin									BeginUpdate(ListWindow);									List^^.listdefProc^ := Ptr(@MyListDef);									LUpdate(ListWindow^.visRgn,List);									EndUpdate(ListWindow);								end;							ActivateEvt :								begin									LActivate(Odd(Event.modifiers),List);									InvalRect(ListWindow^.PortRect);								end;							keyDown,AutoKey :								begin									trickVar.I := Event.Message;									CharCode := trickVar.chr0;									if BitAnd(Event.modifiers,CmdKey) = CmdKey then										ProcessMenu(MenuKey(CharCode));								end;						end;					end;			until Done;		end;{**************************}	procedure SetUpThings;		var			index : integer;			Dummy:integer;		begin			for index := beginMenu to endMenu do				myMenus[index] := GetMenu(index);			AddResMenu(myMenus[appleMenu],'DRVR');			for index := beginMenu to endMenu do				InsertMenu(myMenus[index],0);			DrawMenuBar;			MakeStateTable;			Dummy:=InitSPort(SPortA,baud2400,stop10,noParity,data7,1000,xOnXOff,xOnXOff);			changed:=false;			InMem:=False;			FromFile:=False;			ParticleCount:=0;		end;{*******************}	procedure InitThings;		var			applrefNum: integer;			hndl:       Handle;			Screen : Rect;		begin			InitGraf(@thePort);			MoreMasters;			MoreMasters;			MoreMasters;			InitFonts;			InitWindows;			InitMenus;			TEInit;			InitCursor;			applrefNum := CurResFile;			UseResFile(0);			SetResLoad(false);			hndl := GetResource('PACK',0);			SetResLoad(true);			UseResFile(applrefNum);			if hndl = nil then				InitPack(0);			Screen := ScreenBits.bounds;			with Screen do				begin					SetRect(DragArea,left+4,top+24,right-4,bottom-4);					SetRect(GrowArea,left,top+24,right,bottom);				end;			FlushEvents(everyEvent,0);			Done:= false;		end;{***********************}	begin		initThings;		SetUpThings;		MainEventLoop;		AllDone;	end.