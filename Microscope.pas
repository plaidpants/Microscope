program Microscope;	{$I TML:Library:MemTypes.ipas}	{$I TML:Library:QuickDraw.ipas}	{$I TML:Library:OSIntf.ipas}	{$I TML:Library:ToolIntf.ipas}	{$I TML:Library:PackIntf.ipas}	{$I TML:Library:mews.ipas}	{$I TML:Library:ListMgrIntf.ipas}	{$I TML:Library:FileIo.iPas}	{$L MicroscopeRsrc}  	{$B+}  	{$T APPL SKEL }	type		{My Types}				arr4=array[1..4] of real; 		HeaderType=record 								Filename:str255; 								NumParticle:Integer; 								 								Event:str255; 								Date:str255; 								operator:str255; 								ShrinkFactZT:Real; 								ShrinkFactZM:Real; 								Magnification:Real; 								ZZO:Real; 								X:arr4; 								y:arr4; 								z:arr4; 								ShrinkFactAN:Real; 								dipofprimary:real; 							end; 		ParticleType=record 								Number:Str255; 								theta:real; 								ZScaleDiv:Real; 								Ymicrons:real; 								GrainCount:real; 								P:Real; 								L:real; 								Fate:str255; 								 								Fwd:ParticlePointer; 								Backward:ParticlePointer;								beta:real;					{beta}								degrees:real;				{beta expressed in degrees}								azimuth:real;				{azimuth angle}								azidegree:real;			{azimuth angle expressed in degress}								pseudo:real;				{pseudoripidity}								dip:real;						{slope of children particles with respect to the primary}								x:real;						{the value calculated from the raw data}								y:real;						{the value calculated from the raw data}								z:real;						{the value calculated from the raw data}							end;				{Real To String Types}				charKind = ( digit, a_sign, decimalPoint, space, an_E, other);				State    = ( start, sign, mantissa, period, fraction, s_notation,s_sign, s_digit, error, finish);					const		HeaderRes=6000;		ParticleRes=6001;		pi=3.14159264;	var		{MEWS varibles}				Done	    : boolean;		{My Global Varibles}		ListDialog:DialogPtr;		Header:HeaderType;		Particle:ParticleType;		changed:Boolean;		InMem:Boolean		List:ListHandle;		ListWindow:WindowPtr;		{RealtoString Vars}				stateTable:array [start..finish, digit..other] of state;		stateNow:state;	procedure CalcParticle(var Particle:ParticleType;													Header:HeaderType);		{michael heinrich}		{5/28/86}		{this program will take raw data recorded by}		{workers using optical microscopes for cosmic ray research}		{the raw data is converted into x,y,z coordinates }				procedure particleStuff;			{inputs the data for the individual particles}			{in the star and calculates their dips}			begin {particle}				with Particle do					dip:=(ZScalediv)/(ymicrons);			end;{particle}		procedure calculate;			{calculates x,y,z}			{x,y,z are 1 dimensional arrays used by research}			begin {calculate}				Particle.x:=(Particle.ymicrons)*sin((Particle.theta)*(pi/180));				Particle.y:=(Particle.ymicrons)*cos((Particle.theta)*(pi/180));				if abs(Particle.theta)<=90 then					Particle.z:=(Particle.dip-header.dipofprimary)*(Particle.ymicrons)*(header.ShrinkFactAN)				else					Particle.z:=(Particle.dip+header.dipofprimary)*(Particle.ymicrons)*(header.ShrinkFactAN);			end;{calculate}		procedure research1;   		{written by michael heinrich}   		{5/8/86}   		{this program will take data from a data file }   		{which specifies x,y,z coordinates and calculate}   		{beta,pseudoripidity,and azimuth angle}       	{this procedure reads and manipulates one }       	{line of data from the dataout}			var				j:integer;			procedure calcbeta;			{calculates beta}				begin {beta}					Particle.beta:=arctan(sqrt(sqr(Particle.x)+sqr(Particle.z))/abs(Particle.y));					if abs(Particle.y)<>Particle.y then						Particle.beta:=-Particle.beta;					if Particle.y<0 then						Particle.beta:=Particle.beta+pi;					Particle.degrees:=Particle.beta*180/pi				end;{beta}			procedure psuedoripidity;				{calculates pseudoripidity}				begin {psuedoripidity}					Particle.pseudo:=-ln(abs(sin(Particle.beta/2)/cos(Particle.beta/2)));				end;{psuedoripidity}			procedure azimuthangle;				{calculates azimuth angle}				begin {azimuthangle}					if Particle.z=0 then						Particle.azimuth:=(pi/2)					else						begin         {z<>0}							Particle.azimuth:=arctan(abs(Particle.x/Particle.z));								{computer won't take - values in function}							if abs(Particle.x/Particle.z)<>(Particle.x/Particle.z) then								Particle.azimuth:=-Particle.azimuth;							{corrected for - values}						end;											{now implement Dr. Frier's sign convention}					if Particle.z < 0 then							{z < 0}							Particle.azimuth:=Particle.azimuth+pi					else    {z >= 0}						begin							if Particle.x<0 then									{z >= 0 and x < 0}										Particle.azimuth:=Particle.azimuth+2*pi;						end;													Particle.azidegree:=Particle.azimuth*180/pi;			end;{azimuthangle}			begin {research}				calcbeta;				psuedoripidity;				azimuthangle;			end;{research}		begin {NHmethod}			particleStuff;			calculate;			research1;		end;			procedure CalcHeader(var Header:HeaderType);			{calculates the dip of the primary}				var			n:integer;			{the # of points at which the primary was measured}			j:integer;			{j will be the array indice counter throughout}			partialdip:real;	{partial sum of dip}		begin {primary}			partialdip:=0;			{at how many points was the primary measured};			{send in each x,y,z cooridinate}			if (header.x[4]=0) and (header.y[4]=0) and (header.z[4]=0) then				n:=3			else n:=4;				for j:=n downto 2 do					partialdip:= ((header.z[j]-header.z[j-1])/(header.y[j]-header.y[j-1]))+partialdip;			if Header.ShrinkFactZM<>0 then				Header.ShrinkFactAN:=Header.ShrinkFactZT/Header.ShrinkFactZM;			header.dipofprimary:= (partialdip/((n-1)*1000))*(header.shrinkFactAN);		end;{primary}     procedure AddParticle(	Particle				:ParticleType);		begin			LAddColumn(1,Pos,List)			LSetCell(Pointer(Ord(@Particle)+1),Length(Particle),Cell,List);		end;     procedure DeleteParticle;		begin			if ParticlePos<>nil then				begin					if ParticlePos^.Backward=nil then						begin							ParticleTop:=ParticlePos^.Fwd;							Dispose(ParticlePos);							ParticlePos:=ParticleTop;						end					else						begin							ParticleTemp:=ParticlePos;							ParticlePos:=ParticlePos^.Backward;							ParticlePos^.Fwd:=ParticleTemp^.Fwd;							if ParticleTemp^.Fwd<>nil then								ParticleTemp^.Fwd^.Backward:=ParticlePos;							Dispose(ParticleTemp);						end;					NumberParticles:=NumberParticles-1;				end;		end;	procedure CleanParticle(var Particle:ParticleType);		begin			with Particle do				begin					number:='';					theta:=0; 					ZScaleDiv:=0; 					Ymicrons:=0; 					GrainCount:=0; 					P:=0; 					L:=0; 					Fate:='';					beta:=0;					pseudo:=0;					azimuth:=0;					degrees:=0;					azidegree:=0;					dip:=0;					x:=0;					y:=0;					z:=0;				end;		end;	procedure CleanHeader;		var			i:integer;		begin			with Header do				begin					Event:=''; 					Date:=''; 					operator:=''; 					ZZO:=0; 					ShrinkFactZT:=0; 					ShrinkFactZM:=0; 					Magnification:=0; 					for i:=1 to 4 do 						begin 							X[i]:=0.0; 							y[i]:=0.0; 							z[i]:=0.0; 						end; 											dipofprimary:=0; 					ShrinkFactAN:=0;				end;		end;	Procedure ForwardParticle(var ParticlePos:ParticlePointer);		begin			if ParticlePos^.Fwd<>nil then				ParticlePos:=ParticlePos^.Fwd;		end;	Procedure BackwardParticle(var ParticlePos:ParticlePointer);		begin			if ParticlePos^.Backward<>nil then				ParticlePos:=ParticlePos^.Backward;		end;	function Power (Base, Expo : real) : Real;		begin			power := exp(expo * ln(Base));		end;	procedure makeStateTable;  var     st : state;     begin    {*                         STATE TABLE                                *}  {*                                                                    *}  {*             digit     a_sign   point     space   an_E       other  *}  {* ------------------------------------------------------------------ *}  {* start       mantissa  sign     period    start   error       error *}  {* sign        mantissa  error    period    error   error       error *}  {* mantissa    mantissa  error    period    finish  s_notation  error *}  {* period      fraction  error    error     error   error       error *]  {* fraction    fraction  error    error     finish  s_notation  error *}  {* s_notation  s_digit   s_sign   error     error   error       error *}  {* s_sign      s_digit   error    error     error   error       error *}  {* s_digit     s_digit   error    error     finish  error       error *}  {* finish      error     error    error     finish  error       error *}      {**** digit }        for st := start to mantissa do      stateTable [ st, digit ] := mantissa;        for st := period to fraction do      stateTable [ st, digit ] := fraction;        for st := s_notation to s_digit do      stateTable [ st, digit ] := s_digit;    stateTable [finish, digit] := error;        {**** a_sign }        stateTable [start, a_sign] := sign;    for st := sign to fraction do      stateTable [ st, a_sign ] := error;          stateTable [s_notation, a_sign] := s_sign;    for st := s_sign to finish do      stateTable [ st, a_sign ] := error;          {**** decimalPoint }        for st := start to mantissa do      stateTable [ st, decimalPoint ] := period;       for st := period to finish do      stateTable [ st, decimalPoint ] := error;    {**** space }        stateTable [start, space] := start;    stateTable [sign, space] := error;    stateTable [mantissa, space] := finish;    stateTable [period, space] := error;    stateTable [fraction, space ] := finish;    for st := s_notation to s_sign do      stateTable [ st, space ] := error;    for st := s_digit to finish do      stateTable [ st, space ] := finish;    {**** an_E }        for st := start to sign do      stateTable [ st, an_E ] := error;    stateTable [ mantissa, an_E ] := s_notation;    stateTable [ period, an_E ] := error;    stateTable [ fraction, an_E ] := s_notation;    for st := s_notation to finish do      stateTable [ st, an_E ] := error;       {**** other }        for st := start to finish do      stateTable [ st, other ] := error;        end; {makeStateTable} 	procedure realToString (realNum : real; var outputString : str255);{convert a real number to a string}  const      maxDigit      = 20;        var      exp           : char;      i, j,      expLength,      beforeDecimal : integer;      r,      temp          : real;      tempString    : str255;      ScientificNotation : boolean;      procedure PositiveExp (var r : real; var length : integer);      begin      length := 0;          {count the number of digits before decimal point}      while r >= 10.0 do      begin	  r := r/10.0;	  length := length + 1;      end;    end; {PositiveExp}          function NegativeExp (var r : real; var length: integer) : boolean;      const      digAfterDecimal = 5;          var      temp : real;          begin      temp := r;      length := 0;      if r <> 0 then          {count the number of leading zeros for a number less than zero}	  while r < 1 do	  begin	    r := r * 10;	    length := length + 1;	  end;      if length > digAfterDecimal then          NegativeExp := true {use exponent to present the small real number}      else       begin           NegativeExp := false;	  r := temp;      end;    end; {NegativeExp}          begin {realToString}       r := abs(realNum);           if NegativeExp (r, expLength) then     begin         beforeDecimal := 1; 	 ScientificNotation := true;         exp := '-';     end     else     begin        PositiveExp (r, expLength);	if expLength  >= maxDigit - 2 then	begin           beforeDecimal := 1;	   ScientificNotation := true;	   exp := '+';	end	else	begin	    beforeDecimal := expLength + 1; {use exponent to present the big real number}	    ScientificNotation := false;	end;     end; {else}        {fix the real number convertion error}     temp := 1.0;     for i := 1 to 18 do         temp := temp * 10.0;     r :=  r + 0.5  / temp;           {fix convertion error}     if trunc(r) = 10 then     begin         r := 1.0;	 expLength := expLength - 1;     end;          {convert the numbers before decimal point to the string }     for i := 1 to beforeDecimal do     begin	 outputString[i] := chr (trunc (r) + ord('0'));	 r := (r - trunc (r)) * 10.0;     end;         outputString [beforeDecimal +1] := '.';          {convert the numbers after decimal point to the string }     for i := (beforeDecimal+2) to maxDigit do     begin	 outputString[i] := chr ( trunc (r) + ord('0') );	 r := (r - trunc (r)) * 10.0;     end;               if ScientificNotation then     {use exponent to present the real number}     begin	 outputString[maxDigit+1] := 'E';	 outputString[maxDigit+2] := exp;	 numToString (expLength, tempString);	 insert(tempString,outputString,maxDigit+3);     end;          if realNum < 0 then {negative real number}     begin         tempString := '-';	 insert(tempString,outputString,1);     end;  end; {realToString}	procedure stringToReal (inputString : str255; var realNum : real);	{converts a string to a real number}  var     extended       : longInt;    prevState      : state;    man,    frac,    place,    characteristic : real;    i,    width,    integer_sign,     mantissaPosi   : integer;    exp            : char;                  function class ( ch: char) : charKind;  { classify the character kinds }      begin      case ch of	'0','1','2','3','4','5','6','7','8','9': class := digit;	'+','-' : class := a_sign;	'.'     : class := decimalPoint;	' '     : class := space;	'E','e' : class := an_E;	otherwise class := other;      end;    end; {class}  begin {stringToReal}     stateNow       := start;     prevState      := start;     man            := 0.0;     frac           := 0.0;     place          := 1;     exp            := '+';     integer_sign   := 1;     extended       := 0;     mantissaPosi   := 0;     exp := '+';     realNum := 0;          i     := 1;     width := length (inputString);          {check and convert each character in the string}     while (i<= width) and (stateNow <> error) do     begin         prevState := stateNow;         stateNow := stateTable [stateNow, class (inputString[i])];	 case stateNow of	   sign     : if inputString[i] = '-' then integer_sign := -1;	   mantissa : 	            begin		        man := man * 10 + ord (inputString[i]) - ord ('0');			mantissaPosi := mantissaPosi + 1;		    end;	   fraction : 		    begin		      frac := frac * 10 + ord (inputString[i]) - ord ('0');		      place := place * 10;		    end;	    s_sign  : if inputString[i] = '-' then exp := '-';	    s_digit : extended := extended * 10 + ord (inputString[i]) - ord ('0');	    otherwise;	 end; {case}	 	 i := i + 1;     end; {while}          if (stateNow = sign) or (stateNow = s_sign) or (stateNow = s_notation) or        ((stateNow = period) and (prevState = start)) then 	    stateNow := error;          if (extended + mantissaPosi - 1) > maxInt then         stateNow := error;           if (stateNow <> error) and (stateNow <> start) then     begin       characteristic := 1;       for i := 1 to extended do	   characteristic := characteristic * 10;       if exp = '+' then	    realNum := integer_sign * (man + frac/place) * characteristic        else  	    realNum := integer_sign * (man + frac/place) / characteristic;      end;  end; {stringToReal}	Procedure SetDlgStr(	DialogPointer	:DialogPtr;										Item				:integer;										TheString		:str255);		var			ItemType		:integer;			TextHandle		:Handle;			Box					:rect;		begin			GetDItem(DialogPointer,Item,ItemType,TextHandle,Box);			SetItext(TextHandle,TheString);		end;	procedure SetReal(	DialogPointer		:DialogPtr;										Item					:integer;										TheReal				:real);		var			ItemType		:integer;			TextHandle		:Handle;			Box					:rect;			TheString		:str255;		begin			GetDItem(DialogPointer,item,ItemType,TextHandle,Box);			RealToString(TheReal,TheString);			SetItext(TextHandle,TheString);		end;	function GetDlgStr(	DialogPointer	:DialogPtr;										Item				:integer):str255;		var			ItemType		:integer;			TextHandle		:Handle;			Box					:rect;			TheString		:str255;		begin			GetDItem(DialogPointer,Item,ItemType,TextHandle,Box);			GetItext(TextHandle,TheString);			GetDlgStr:=TheString;		end;	function GetReal(	DialogPointer		:DialogPtr;									Item					:integer):Real;		var			ItemType		:integer;			TextHandle		:Handle;			Box					:rect;			RealString		:str255;			TheReal			:real;		begin			GetDItem(DialogPointer,item,ItemType,TextHandle,Box);			GetItext(TextHandle,RealString);			StringToReal(RealString,TheReal);			GetReal:=TheReal;		end;	Procedure Modal(	var cancel					:Boolean);		Var			itemHit	:integer;			Done		:boolean;  		begin  			cancel:=false;  			done:=false;        		repeat            		begin {repeat}               		ModalDialog(nil,itemHit);               		case itemHit of                 			1:Done:=true;                 			2:begin                     				done:=true;                      				cancel:=true;                    			end;							otherwise;                		end;{case}              		end;{repeat}          		until done;    	end;{dialog}    procedure HeaderDialog(var cancel:boolean);		var			DialogPointer	:DialogPtr;			seconds:longint;			i:integer;		begin			if Header.Date = '' then				begin					getdatetime(seconds);					IUDateString(seconds,shortDate,Header.Date);				end;			if Header.Event = '' then				begin				end;			if Header.Operator = '' then				begin				end;							DialogPointer:=GetNewDialog(HeaderRes,nil,pointer(-1));						SetDlgStr(DialogPointer,3,Header.Event);			SetDlgStr(DialogPointer,4,Header.Date);			SetDlgStr(DialogPointer,5,Header.Operator);			SetReal(DialogPointer,6,Header.ShrinkFactZT);			SetReal(DialogPointer,7,Header.ShrinkFactZM);			SetReal(DialogPointer,8,Header.Magnification);			SetReal(DialogPointer,9,Header.ZZO);			for i:=1 to 4 do				begin					SetReal(DialogPointer,10+(i-1)*3,Header.X[i]);					SetReal(DialogPointer,11+(i-1)*3,Header.Y[i]);					SetReal(DialogPointer,12+(i-1)*3,Header.Z[i]);				end;			SetReal(DialogPointer,22,Header.ShrinkFactAN);			SetReal(DialogPointer,23,Header.dipofprimary);						Modal(Cancel);			if not cancel then				begin					Header.Event:=GetDlgStr(DialogPointer,3);					Header.Date:=GetDlgStr(DialogPointer,4);					Header.Operator:=GetDlgStr(DialogPointer,5);					Header.ShrinkFactZT:=GetReal(DialogPointer,6);					Header.ShrinkFactZM:=GetReal(DialogPointer,7);					Header.Magnification:=GetReal(DialogPointer,8);					Header.ZZO:=GetReal(DialogPointer,9);					for i:=1 to 4 do						begin							Header.X[i]:=GetReal(DialogPointer,10+(i-1)*3);							Header.Y[i]:=GetReal(DialogPointer,11+(i-1)*3);							Header.Z[i]:=GetReal(DialogPointer,12+(i-1)*3);						end;											CalcHeader(Header);				end;			CloseDialog(DialogPointer);		end;    procedure ParticleDialog(	var Particle		:ParticleType;    											var Cancel		:Boolean);		var			DialogPointer			:DialogPtr;		begin			DialogPointer:=GetNewDialog(ParticleRes,nil,pointer(-1));						SetDlgStr(DialogPointer,3,Particle.Number);			SetReal(DialogPointer,4,Particle.Theta);			SetReal(DialogPointer,5,Particle.ZScaleDiv);			SetReal(DialogPointer,6,Particle.YMicrons);			SetReal(DialogPointer,7,Particle.GrainCount);			SetReal(DialogPointer,8,Particle.P);			SetReal(DialogPointer,9,Particle.L);			SetDlgStr(DialogPointer,10,Particle.fate);			SetReal(DialogPointer,11,Particle.Beta);			SetReal(DialogPointer,12,Particle.degrees);			SetReal(DialogPointer,13,Particle.azimuth);			SetReal(DialogPointer,14,Particle.azidegree);			SetReal(DialogPointer,15,Particle.pseudo);			SetReal(DialogPointer,16,Particle.dip);			SetReal(DialogPointer,17,Particle.X);			SetReal(DialogPointer,18,Particle.Y);			SetReal(DialogPointer,19,Particle.Z);			Modal(Cancel);			if not cancel then				begin					Particle.Number:=GetDlgStr(DialogPointer,3);					Particle.Theta:=GetReal(DialogPointer,4);					Particle.ZScaleDiv:=GetReal(DialogPointer,5);					Particle.YMicrons:=GetReal(DialogPointer,6);					Particle.GrainCount:=GetReal(DialogPointer,7);					Particle.P:=GetReal(DialogPointer,8);					Particle.L:=GetReal(DialogPointer,9);					Particle.fate:=GetDlgStr(DialogPointer,10);					CalcParticle(particle,header);				end;			CloseDialog(DialogPointer);		end;	procedure CheckMenus;		begin		end;	procedure AreYouSure(	TheString	:Str255;											var cancel	:boolean);		begin		end;	procedure UserMenu{(menu, Item: integer)};		procedure FileMenu;			{procedures for menu}			procedure NewList;				var					CSize:Point;					DataBounds:Rect				begin					if InMem then						begin							LDispose(List);							ShutWindow(ListWindow);						end;						createWindow(ListWindow,Header.Filename,DocWindow,[GoAway,Grow,Hscroll,Vscroll],50,50,100,100);					SetPort(ListWindow);					TextFont(1);										Databounds.top:=0;					DataBounds.Left:=0;					DataBounds.Bottom:=0;					DataBounds.Right:=0;						CSize.v:=16;					CSize.h:=1000;										list:=Lnew(ListWindow^.PortRec,databounds,cSize,0,Listwindow,false,true,true,true);					List^^.ListDefProc:=NewHandle(0);					List^^.ListDefProc^:=ptr(@MyListDef);					List^^selFlags:=lOnlyOne;					LDoDraw(true,TheList);				end;			procedure ReadHeader;				begin				end;			procedure ReadParticles(ParticlePos:ParticlePointer);				begin				end;			procedure GetReadFile(var Cancel:boolean);				var					pt:point;					FileType:SFTypeList;					reply:SFReply;				begin					pt.h:=50;					pt.v:=50;					FileType[0][1]:='T';					FileType[0][2]:='E';					FileType[0][3]:='X';					FileType[0][4]:='T';					SFGetFile(pt,'Enter File',nil,1,filetype,nil,reply);					cancel:=Reply.good;					if not cancel then						header.filename:=reply.fName;				end;			{the menu procedures}			procedure NewFile;				var					cancel:boolean;					begin					cancel:=False;					if changed and InMem then						AreYouSure('Are you sure you want to throw away Changes to this file?',Cancel);					if not cancel then						begin							CleanHeader;							HeaderDialog(Cancel);							if not Cancel then								begin									Header.filename:='untitled';									Header.NumParticle:=0;									NewList;									changed:=True;									InMem:=True;								end;						end;				end;			procedure OpenFile;				var					Dialog:DialogPtr;					pt:point;					FileType:SFTypeList;					Reply:SFReply;					Cancel:Boolean;				begin					if not saved then						AreYouSure('Are you sure you want to throw away Changes to this file?',Cancel);					if not cancel then						begin							GetReadFile(Cancel);							if not cancel then								begin									open(datafile,header.filename);									reset(datafile);									ReadHeader;									New(ParticleTop);									ParticlePos:=ParticleTop;									ReadParticles(ParticlePos);									close(datafile);									CheckMenus;									Saved:=True;								end;						end;				end;			Procedure CloseFile;				begin				end;			Procedure SaveAsFile;				begin				end;			Procedure SaveFile;				begin				end;			Procedure RevertFile;				begin				end;			Procedure AppendFile;				begin				end;			Procedure PageSetUp;				begin				end;			Procedure PrintFile;				begin				end;			begin				case Item of					1:NewFile;					2:OpenFile;					3:CloseFile;					4:;					5:SaveFile;					6:SaveAsFile;					7:RevertFile;					8:;					9:AppendFile;					10:;					11:PageSetUp;					12:PrintFile;					13:;					14:Done := true;				end;			end;		Procedure EditMenu;			begin			end;		procedure ParticleMenu;			procedure AddParticleMenu;				var					cancel:boolean;					Particle:ParticleType;				begin					CleanParticle(Particle);					ParticleDialog(Particle,cancel);					if not cancel then						begin							AddParticle(Particle);							AddUpdate;							Saved:=False;						end;				end;			procedure AddContinuousParticle;				var					cancel:boolean;					Particle:ParticleType;				begin					repeat						begin							CleanParticle(Particle);							ParticleDialog(Particle,cancel);							if not cancel then								begin									AddParticle(Particle);									AddUpdate;									Saved:=False;								end;						end;					until cancel;				end;			procedure EditParticle;				var					cancel:boolean;				begin					ParticleDialog(ParticlePos^,cancel);					AddUpdate;					Saved:=False;				end;			procedure ClearParticle;				begin					CleanParticle(ParticlePos^);					AddUpdate;					Saved:=False;				end;			procedure DeleteParticleMenu;				begin					DeleteParticle;					AddUpdate;					Saved:=False;				end;			begin				case Item of					1:AddParticleMenu;					2:AddContinuousParticle;					3:EditParticle;					4:ClearParticle;					5:DeleteParticleMenu;				end;			end;		procedure HeaderMenu;			procedure EditHeader;				var					cancel:boolean;				begin					HeaderDialog(Cancel);					if not cancel then						Saved:=False;				end;			Procedure ClearHeader;				begin					CleanHeader;					Saved:=False;				end;			begin				case Item of					1:EditHeader;					2:ClearHeader;				end;			end;		begin			case Menu of				1:;				2:FileMenu;            	3:EditMenu;            	4:ParticleMenu;            	5:HeaderMenu;			end;		end;	procedure UserControl{( WhichWindow: WindowPtr; P: point;                         TheControl: ControlHandle;			 ThePartCode: integer )};		begin		end;	procedure UserClick{(P: point; WhichWindow: WindowPtr)};		var			dummy:boolean;					begin			Dummy:=LClick(P,Event.Modifiers,TheList);		end;	procedure UserDoubleClick{(P: point; WhichWindow: WindowPtr)};		begin		end;	procedure UserDrag{(State: DragStates;                       OldPoint, NewPoint: point;		       WhichWindow: WindowPtr )};		begin		end;	procedure UserKeypress{(KbdChar: char)};		begin		end;	procedure UserUpdate{(WinIndex: WindowPtr)};		begin		    LUpdate(ListWindow^.visRgn,theList);		end;	procedure UserClose{(WinIndex: WindowPtr; var Ok: boolean)};		begin			if changed and InMem then				AreYouSure('Are you sure you want to throw away Changes to this file?',Cancel);			ok := Not Cancel;		end;	procedure UserScroll{(W: WindowPtr; R: Rect; dx, dy: integer)};		begin		end;	procedure UserAboutUs;		begin		end;	procedure UserDialog{( Dp: DialogPtr; UsrItem: integer )};		begin		end;	procedure UserActivate{(WinIndex: WindowPtr)};		begin			LActivate(Odd(Event.modifiers),theList);		end;	procedure UserDeActivate{(WinIndex: WindowPtr)};		begin		end;	procedure UserEvent{(Ev: eventRecord)};		begin		end;	procedure init;		var			cancel:boolean;		begin			MEWSInit;			MakeStateTable;						Done := false;			changed:=false;			InMem:=False;						CreateMenus(1, 5);			ArrowCursor;		end;	begin { Main Program }		init;		repeat			MEWSPoll;		until Done;	end { End of Main Program } .