program Micro;	{$B+}															{Set bundle bit so finder will use my icon}	{$R+}															{Do Math error checking}	{$T APPL MICR}										{set my file type and creator}	{$L MicroRsrc}										{Load my reasources (dialog boxes etc..)}	{$I TML:Library:MemTypes.ipas}		{Load all relavant include files}	{$I TML:Library:QuickDraw.ipas}	{$I TML:Library:OSIntf.ipas}	{$I TML:Library:ToolIntf.ipas}	{$I TML:Library:PackIntf.ipas}	{$I TML:Library:ListMgrIntf.ipas}	{$I TML:Library:MacPrint.ipas}	{$I TML:Library:FileIo.iPas}	{$I TML:Library:Serial.iPas}	type		{My Types}		arr4=			array[1..4] of real;		{arrary of 4 reals}		ari4=			array[1..4] of integer;	{Arrary of 4 integers}		strtype=			string[10];							{string size to shrink record size} 		HeaderType=								{Header storage record definition} 			record 				Reply:SfReply;				{current File system reply from last load} 				NumParticle:Integer;	{counter holds number of particles in list} 				slopexy:real;					{other data for header} 				slopezy:real; 				Event:strtype; 				Date:strtype; 				operator:strtype; 				ShrinkFactZT:Real; 				ShrinkFactZM:Real; 				Magnification:Real; 				ZZO:Real; 				X:arr4; 				y:arr4; 				z:arr4; 				Beam:strtype; 				Plate:strtype; 				part:strtype; 				Rangetostar:strtype; 				Primary:strtype; 				Frag:strtype; 				a:strtype; 				p:strtype; 				M:strtype; 				FBL:strtype; 				NB:ari4;{Used for measuring energy of the particles} 				G1:ari4;{NB,G1, G2, G3 are the result of particles with} 				G2:ari4;{different energies there is one measurement} 				G3:ari4;{for each quadrant} 				NH:ari4; 				energyQ:arr4; 				energytotal:real; 				NHtotal:integer; 				FtoBBlack:real; 				FtoBGrey:real; 				BBL:strtype; 				ShrinkFactAN:Real; 				dipofprimary:real; 				dummy1:real;					{dummy's in case they need more info}				dummy2:real;				dummy3:real;				dummy4:real;				dummy5:real;				dummy6:real;				dummy7:real;				dummy8:real;				dummy9:strtype;				dummy0:strtype; 			end;		ParticlePtr=							{pointers are used to access particles in list because list can hold}			^ParticleType;					{only 32K of data not much for particles 212 bytes long so only a pointer}															{to the data is saved in the list leaving about max 3000 particle}															 		ParticleType=							{Holds each particle information} 			record 				Number:strtype;				{Particle information} 				xsec:real; 				ysec:real; 				zsec:real; 				GrainCount:real; 				P:real; 				L:real;				beta:real;					{beta}				degrees:real;				{beta expressed in degrees}				azimuth:real;				{azimuth angle}				azidegree:real;			{azimuth angle expressed in degress}				pseudo:real;				{pseudoripidity}									{slope of children particles with respect to the primary}				deltax:real;						{the value calculated from the raw data}				deltay:real;						{the value calculated from the raw data}				deltaz:real;                         {the value calculated from the raw data}				bigx:real;				bigz:real;				deltar:real;				xstar:real;				ystar:real;				zstar:real;			end;	const		HeaderNHRes=						{reasource numbers of dialog boxes}			6000;		ParticleNHRes=			6001;		DebugRes=			6002;		AreSureRes=			6003;		AboutRes=			6004;		HeaderLTRes=			6005;		ParticleLTRes=			6006;					appleMenu =							{reasource number of menus}			300;		fileMenu =			301;		editMenu =			302;		particleMenu =			303;		HeaderMenu =			304;		beginMenu =			300;		endMenu =			304;		pi=			3.1415926535898;	var		{Mac Varibles}		Done:										{program done flag}			Boolean;		myMenus:								{Handles to each menu}			 array[beginMenu..endMenu] of MenuHandle;		DragArea,								{area that make sure you don't drag somting off the screen}		GrowArea:								{Largest window grow}			Rect;		PgSetUp:								{Global printer values}			THPrint;		MyStRec:								{print record}			TPrStatus;		PrinterPort:						{graphic port for printing}			TPPrPort;		{My Global Varibles}		InMem,									{is a file in memory}		FromFile,								{was this file new or from disk}		changed:								{has it been changed}			Boolean;		Header:									{only one header so global}			HeaderType;		List:										{only one list so global}			ListHandle;		ListWindow:							{only one window to go with one list so global}			WindowPtr;{********************}	procedure DebugDialog(TheInteger:integer);    	forward;{****************************************************}	procedure calcparticle(var particle:particletype;header:headertype);		procedure changeofxyz(var particle:particletype;header:headertype);			begin{ changeofxyz}				particle.deltay:=(particle.ysec-particle.ystar)*1000;				particle.deltax:=(particle.xsec-particle.xstar)*(header.Magnification)-(header.slopexy*particle.deltay);				particle.deltaz:=(particle.zsec-particle.zstar)*(header.ShrinkFactAN)-(header.slopezy*particle.deltay);			end;{ changeofxyz}		procedure answer(var particle:particletype);			procedure beta(var particle:particletype);				{calculates beta}				begin					particle.beta:=arctan(sqrt(sqr(particle.deltax)+sqr(particle.deltaz))/abs(particle.deltay));					If particle.deltay>0 then						particle.beta:= pi+(-particle.beta);					particle.degrees:=particle.beta*180/pi;				end;			procedure pseudoripidity(var particle:particletype);				{calculates pseudoripidity}				begin					particle.pseudo:=-ln(abs(sin(particle.beta/2)/cos(particle.beta/2)));				end;			procedure azimuthangle(var particle:particletype);				{calculates azimuth angle}				begin					if particle.deltaz=0 then						particle.azimuth:=(pi/2)					else						 particle.azimuth:=arctan(abs(particle.deltax/particle.deltaz));					if particle.deltaz<>0 then						begin							if abs(particle.deltax/particle.deltaz)<>(particle.deltax/particle.deltaz) then								particle.azimuth:=-particle.azimuth;						end					else						if particle.deltax<0 then							particle.azimuth:=-particle.azimuth;					if particle.deltaz>=0 then						begin							if particle.deltax<0 then								particle.azimuth:=particle.azimuth+2*pi;						end					else						particle.azimuth:=particle.azimuth+pi;					particle.azidegree:=particle.azimuth*180/pi;				end;			procedure calcxandz(var particle:particletype);				begin{calcxandz}					particle.deltar:=1000*sin(particle.beta)/cos(particle.beta);					particle.bigx:=particle.deltar*sin(particle.azimuth);					particle.bigz:=particle.deltar*cos(particle.azimuth);				end;{calcxandz}			begin{answer}				beta(particle);				pseudoripidity(particle);				azimuthangle(particle);				calcxandz(particle);			end;{answer}		begin{calcparticle}			changeofxyz(particle,header);			answer(particle);		end;{calcparticle}	procedure calcheader(var Header:HeaderType);		{Michael Heinrich}		{8/20/86}		{The purpose of this program is to }		{calculate theta, phi,pseudoripidity}		{for particles given a primary and secondary}		{measurements on the particles}		{this is only part of the overall developement}		{the input and output of data will be handled}		{by other parts of the program}		{print option not on disk}		{calculates the dip of the primary}		var				j:integer;{indice counter throughout}				partialdip:real;{partial sum of dip}				K:integer;		Procedure NHEnergy(var header:headertype);			var				k:integer;			begin{NHEnergy}				with header do					begin						for k:=1 to 4 do							begin								energyQ[k]:=12.5*NB[k]+54*G1[k]+146*G2[k]+299*G3[k];								NH[k]:=NB[k]+G1[k]+G2[k]+G3[k];							end;						energytotal:=energyQ[1]+energyQ[2]+energyQ[3]+energyQ[4];						NHtotal:=NH[1]+NH[2]+NH[3]+NH[4];						FtoBBlack:=(NB[1]+NB[4])/(NB[2]+NB[3]);						FtoBGrey:=(G1[1]+G2[1]+G3[1]+G1[4]+G2[4]+G3[4])/(G1[2]+G2[2]+G3[2]+G1[3]+G2[3]+G3[3]);					end;			end;{NHEnergy}		Procedure RecalcParticles(header:HeaderType);			var				i:Integer;				Last:Cell;				particle:ParticleType;				ParticlePointer:ParticlePtr;				len:integer;			begin				len:=SizeOf(ParticlePointer);				last.h:=0;				for i := 1 to Header.NumParticle do					begin						Last.v:=i-1;						LGetCell(pointer(ord(@ParticlePointer)),Len,Last,List);						Particle:=ParticlePointer^;						CalcParticle(Particle,Header);						ParticlePointer^:=Particle;						LSetCell(pointer(ord(@ParticlePointer)),len,Last,List);					end;			end;		begin{calprimary}			with header do				begin					partialdip:=0;					if (x[4]=0) and (y[4]=0) and (z[4]=0) then						k:=3					else					 	k:=4;					for j:=k downto 2 do						partialdip:=((x[j]-x[j-1])/(y[j]-y[j-1]))+partialdip;					slopexy :=(partialdip/((k-1)*1000))*(Magnification);					partialdip:=0;					if Header.ShrinkFactZM<>0 then				    	Header.ShrinkFactAN:=Header.ShrinkFactZT/Header.ShrinkFactZM;					for j:=k downto 2 do						partialdip:=((z[j]-z[j-1])/(y[j]-y[j-1]))+partialdip;					slopezy :=(partialdip/((k-1)*1000))*(ShrinkFactAN);				end;			NHEnergy(header);			RecalcParticles(Header);		end;{calprimary}{********************************************}  	procedure NoFileMenu;  		begin  			Enableitem(MyMenus[appleMenu],0);  			Enableitem(MyMenus[appleMenu],1);  			Enableitem(MyMenus[fileMenu],0);  			Enableitem(MyMenus[fileMenu],1);  			Enableitem(MyMenus[fileMenu],2);  			DisableItem(MyMenus[fileMenu],3);				DisableItem(MyMenus[fileMenu],5);				DisableItem(MyMenus[fileMenu],6);				DisableItem(MyMenus[fileMenu],7);				DisableItem(MyMenus[fileMenu],9);				EnableItem(MyMenus[fileMenu],11);				DisableItem(MyMenus[fileMenu],12);				EnableItem(MyMenus[fileMenu],14);								DisableItem(MyMenus[ParticleMenu],0);								DisableItem(MyMenus[HeaderMenu],0);  		end;  	procedure NewMenuNone;  		begin  			NoFileMenu;  			EnableItem(MyMenus[FileMenu],3);				EnableItem(MyMenus[FileMenu],6);				EnableItem(MyMenus[FileMenu],9);				EnableItem(MyMenus[FileMenu],12);				EnableItem(MyMenus[ParticleMenu],0);				EnableItem(MyMenus[ParticleMenu],1);				EnableItem(MyMenus[ParticleMenu],2);				DisableItem(MyMenus[Particlemenu],3);				DisableItem(MyMenus[ParticleMenu],4);				DisableItem(MyMenus[ParticleMenu],5);				Enableitem(MyMenus[HeaderMenu],0);				Enableitem(MyMenus[HeaderMenu],1);				Enableitem(MyMenus[HeaderMenu],2);  		end;  	procedure NewMenuSome;  		begin  			NewMenuNone;  			EnableItem(MyMenus[ParticleMenu],3);  			EnableItem(MyMenus[ParticleMenu],4);				EnableItem(MyMenus[ParticleMenu],5);  		end;  	procedure OldMenuNone;  		begin				NewMenuNone;				EnableItem(MyMenus[FileMenu],5);				EnableItem(MyMenus[FileMenu],7);  		end;  	procedure OldMenuSome;  		begin  			OldMenuNone;  			EnableItem(MyMenus[ParticleMenu],3);  			EnableItem(MyMenus[ParticleMenu],4);				EnableItem(MyMenus[ParticleMenu],5);  		end;  	procedure DrawMenu;  		begin  			if InMem then  				if fromFile then  					if Header.NumParticle = 0 then  						OldMenuNone  					else  						OldMenuSome  				else  					if Header.NumParticle = 0 then  						NewMenuNone  					else  						NewMenuSome  			else  				NoFileMenu;  			DrawMenuBar;  		end;  {************************}	function Power10 (Expo : integer) : longint;		var			power : longint;			i : integer;		begin			power := 1;			if power <> 0 then				for i := 1 to expo do			power := Power * 10;			power10 := Power;		end;	procedure Real2String (var WholeNumber : Real;		var TheString : Str255;		DecAcc:Integer);		var			integerPart, decimalPart : str255;		begin			NumToString(trunc(abs(wholeNumber)), IntegerPart);			if wholeNumber<0 then				IntegerPart:=concat('-',IntegerPart);			NumToString(round(abs(wholeNumber - trunc(wholeNumber)) * power10(DecAcc)), decimalPart);			TheSTring := concat(IntegerPart, '.', copy('000000', 1, DecAcc - length(DecimalPart)), decimalPart);		end;	procedure String2Real (var WholeNumber : str255;		var TheReal : real);		var			decimalPos : integer;			IntegerPart : longint;			DecimalPart : longint;			zeros : integer;			neg:integer;		begin			DecimalPart := 0;			IntegerPart := 0;			neg:=pos('-',WholeNumber);			if neg=0 then				neg:=1			else				begin					Delete(WholeNumber, 1, Neg);					neg:=-1;				end;			DecimalPos := pos('.', WholeNumber);			if DecimalPos = 0 then				StringtoNum(WholeNumber, IntegerPart)			else				begin					if DecimalPos <> 1 then						StringtoNum(copy(WholeNumber, 1, DecimalPos - 1), integerpart);					Zeros := 0;					Delete(WholeNumber, 1, DecimalPos);					while copy(WholeNumber, 1, 1) = '0' do						begin							Delete(WholeNumber, 1, 1);							Zeros := Zeros + 1;						end;					wholeNumber := copy(WholeNumber, 1, 5);					StringtoNum(WholeNumber, DecimalPart);				end;			TheReal := neg*(IntegerPart + (DecimalPart / Power10(zeros + Length(WholeNumber))));		end;{*************************}	procedure MyListDef(		lMessage :			 Integer;		lSelect :			 Boolean;		lRect :			Rect;		lCell :			Cell;		lDataOffSet :			Integer;		lDataLen :			Integer;		lHandle :			ListHandle);		procedure DoDrawMsg(SelectIt : boolean;				theRect : Rect;				theCell : Cell;				theHandle : ListHandle);			var				Particle:ParticleType;				thestring:str255;				len:Integer;				Box:Rect;				particlePointer:ParticlePtr;			begin				EraseRect(TheRect);				len:=SizeOf(ParticlePointer);				LGetCell(pointer(ord(@ParticlePointer)),Len,TheCell,List);				if len = SizeOf(ParticlePointer) then					begin						Particle:=ParticlePointer^;						textfont(4);						textSize(9);						numtoString(TheCell.v+1,TheString);						setRect(Box,TheRect.left,TheRect.top,theRect.left+25,theRect.top + 10);						TextBox(POINTER(ORD(@theString)+1),Length(theString),Box,TEJustRight);						Real2String(Particle.Xsec,TheString,1);						setRect(Box,TheRect.left+25,TheRect.top,theRect.left+25+50,theRect.top + 10);						TextBox(POINTER(ORD(@theString)+1),Length(theString),Box,TEJustRight);						Real2String(Particle.Zsec,TheString,1);						setRect(Box,TheRect.left+25+50,TheRect.top,theRect.left+25+100,theRect.top +10);						TextBox(POINTER(ORD(@theString)+1),Length(theString),Box,TEJustRight);						Real2String(Particle.Ysec,TheString,3);						setRect(Box,TheRect.left+25+100,TheRect.top,theRect.left+25+150,theRect.top +10);						TextBox(POINTER(ORD(@theString)+1),Length(theString),Box,TEJustRight);						setRect(Box,TheRect.left+25+150,TheRect.top,theRect.left+25+200,theRect.top +10);						TextBox(POINTER(ORD(@Particle.Number)+1),Length(Particle.Number),Box,TEJustRight);						Real2String(Particle.GrainCount,TheString,1);						setRect(Box,TheRect.left+25+200,TheRect.top,theRect.left+25+250,theRect.top +10);						TextBox(POINTER(ORD(@TheString)+1),Length(TheString),Box,TEJustRight);						Real2String(Particle.pseudo,TheString,3);						setRect(Box,TheRect.left+25+250,TheRect.top,theRect.left+25+300,theRect.top +10);						TextBox(POINTER(ORD(@TheString)+1),Length(TheString),Box,TEJustRight);						Real2String(Particle.BigX,TheString,1);						setRect(Box,TheRect.left+25+300,TheRect.top,theRect.left+25+350,theRect.top +10);						TextBox(POINTER(ORD(@TheString)+1),Length(TheString),Box,TEJustRight);						Real2String(Particle.BigZ,TheString,1);						setRect(Box,TheRect.left+25+350,TheRect.top,theRect.left+25+400,theRect.top +10);						TextBox(POINTER(ORD(@TheString)+1),Length(TheString),Box,TEJustRight);						Real2String(Particle.aziDegree,TheString,1);						setRect(Box,TheRect.left+25+400,TheRect.top,theRect.left+25+450,theRect.top +10);						TextBox(POINTER(ORD(@TheString)+1),Length(TheString),Box,TEJustRight);					end;				if SelectIt then					invertRect(theRect);			end;		begin			case lMessage of				lInitMsg:;				lDrawMsg:DoDrawMsg(lSelect,lRect,lCell,lHandle);				lHiliteMsg:invertRect(lRect);				lCloseMsg:;			end;		end;{*************************}	procedure CleanParticle(var Particle:ParticleType);		begin			with Particle do				begin					number:=' ';					xsec:=0; 					ysec:=0; 					zsec:=0; 					GrainCount:=0; 					P:=0; 					L:=0;					beta:=0;					pseudo:=0;					azimuth:=0;					degrees:=0;					azidegree:=0;					deltax:=0;					deltay:=0;					deltaz:=0;					bigx:=0;					bigz:=0;					deltar:=0;					XStar:=0;					YStar:=0;					ZStar:=0;				end;		end;	procedure AddParticle(var	Particle				:ParticleType);		var			Last:Cell;			Dummy:Integer;			aBol:Boolean;			ParticlePointer:ParticlePtr;		begin			last.h:=0;			last.v:=0;			if LGetSelect(true,last,list) then				LSetSelect(False,Last,list);			Dummy:=LAddRow(1,Header.NumParticle+1,List);			Last.h:=0;			Last.v:=Header.NumParticle;			New(ParticlePointer);			ParticlePointer^:=Particle;			LSetCell(pointer(ord(@ParticlePointer)),SizeOf(ParticlePointer),Last,List);			LSetSelect(true,Last,List);			Header.NumParticle:=Header.NumParticle+1;		end;	procedure DeleteParticle(var NoSelect:Boolean);		var			last:Cell;			len:integer;			ParticlePointer:ParticlePtr;		begin			NoSelect:=False;			if LGetSelect(true,Last,List) then				begin					len:=SizeOf(ParticlePointer);					last.h:=0;					LGetCell(pointer(ord(@ParticlePointer)),Len,Last,List);					Dispose(ParticlePointer);					LDelRow(1,Last.v,List);					Header.NumParticle:=Header.NumParticle-1;				end			else				NoSelect:=True;		end;	procedure GetParticle(	var Particle:ParticleType;     											var NoSelect:Boolean);		var			Last:Cell;			len:Integer;			particlePointer:ParticlePtr;		begin			NoSelect:=False;			last.h:=0;			last.v:=0;			if LGetSelect(true,last,list) then				begin					len:=SizeOf(ParticlePointer);					last.h:=0;					LGetCell(pointer(ord(@ParticlePointer)),Len,Last,List);					Particle:=ParticlePointer^;				end			else				NoSelect:=true;		end;	procedure GetLastParticle(var Particle:ParticleType;     											var NoSelect:Boolean);		var			Last:Cell;			len:Integer;			ParticlePointer:ParticlePtr;		begin			NoSelect:=False;			last.h:=0;			Last.v:=Header.NumParticle-1;			len:=SizeOf(ParticlePointer);			LGetCell(pointer(ord(@ParticlePointer)),Len,Last,List);			Particle:=ParticlePointer^;		end;	procedure SetParticle(	var Particle:ParticleType;     										var NoSelect:Boolean);		var			Last:Cell;			ParticlePointer:ParticlePtr;			len:integer;		begin			NoSelect:=False;			last.h:=0;			last.v:=0;			if LGetSelect(true,last,list) then				begin					last.h:=0;					len:=SizeOf(ParticlePointer);					LGetCell(pointer(ord(@ParticlePointer)),Len,Last,List);					ParticlePointer^:=Particle;					LSetCell(pointer(ord(@ParticlePointer)),len,Last,List)				end			else				NoSelect:=true;		end;{******************************}	procedure CleanHeader;		var			i:integer;		begin			with Header do				begin					Beam:='';					Event:=''; 					Date:=''; 					plate:=''; 					part:=''; 					operator:=''; 					rangetostar:=''; 					ZZO:=0; 					ShrinkFactZT:=0; 					ShrinkFactZM:=0; 					Magnification:=0; 					for i:=1 to 4 do 						begin 							X[i]:=0.0; 							y[i]:=0.0; 							z[i]:=0.0; 						end;					dipofprimary:=0; 					ShrinkFactAN:=0; 					primary:=''; 					frag:=''; 					a:=''; 					p:=''; 					M:=''; 					for i := 1 to 4 do 						begin 							NB[i]:=0; 							G1[i]:=0; 							G2[i]:=0; 							G3[i]:=0; 							energyQ[i]:=0; 						end; 					energytotal:=0; 					NHtotal:=0; 					FtoBBlack:=0; 					FtoBGrey:=0; 					FBL:=''; 					BBL:=''; 					slopexy:=0; 					slopezy:=0;				end;		end;{*****************************}	Procedure SetDlgStr255(	Item				:integer;										TheString		:str255;										DialogPointer:DialogPtr);		var			ItemType		:integer;			TextHandle		:Handle;			Box					:rect;		begin			GetDItem(DialogPointer,Item,ItemType,TextHandle,Box);			SetItext(TextHandle,TheString);		end;	Procedure SetDlgStr(	Item				:integer;										TheString		:strtype;										DialogPointer:DialogPtr);		var			ItemType		:integer;			TextHandle		:Handle;			Box					:rect;			dummy:str255;		begin			GetDItem(DialogPointer,Item,ItemType,TextHandle,Box);			dummy:=TheString;			dummy:=copy(dummy,1,10);			SetItext(TextHandle,dummy);		end;	procedure SetReal(	Item					:integer;										TheReal				:real;										DecAcc				:Integer;										DialogPointer:DialogPtr);		var			ItemType		:integer;			TextHandle		:Handle;			Box					:rect;			TheString		:str255;		begin			GetDItem(DialogPointer,item,ItemType,TextHandle,Box);			Real2String(TheReal,TheString,DecAcc);			SetItext(TextHandle,TheString);		end;	procedure SetDlgInt(  Item					:integer;										theInt				:integer;										DialogPointer:DialogPtr);		var			ItemType		:integer;			TextHandle		:Handle;			Box					:rect;			TheString		:str255;		begin			GetDItem(DialogPointer,item,ItemType,TextHandle,Box);			NumToString(TheInt,TheString);			SetItext(TextHandle,TheString);		end;	function GetDlgStr(	Item				:integer;										DialogPointer:DialogPtr):strType;		var			ItemType		:integer;			TextHandle		:Handle;			Box					:rect;			TheString		:str255;			dummy:strtype;		begin			GetDItem(DialogPointer,Item,ItemType,TextHandle,Box);			GetItext(TextHandle,TheString);			dummy:=TheString;			GetDlgStr:=dummy;		end;	function GetReal(	Item					:integer;										DialogPointer:DialogPtr):Real;		var			ItemType		:integer;			TextHandle		:Handle;			Box					:rect;			RealString		:str255;			TheReal			:real;		begin			GetDItem(DialogPointer,item,ItemType,TextHandle,Box);			GetItext(TextHandle,RealString);			String2Real(RealString,TheReal);			GetReal:=TheReal;		end;	function GetDlgInt(	Item					:integer;										DialogPointer:DialogPtr):Integer;		var			ItemType		:integer;			TextHandle		:Handle;			Box					:rect;			IntString		:str255;			TheInt			:LongInt;		begin			GetDItem(DialogPointer,item,ItemType,TextHandle,Box);			GetItext(TextHandle,IntString);			StringtoNum(IntString,TheInt);			GetDlgInt:=TheInt;		end;{********************}	procedure ClearBuffer(var FootStop:Boolean);		var			ch:char;			Dummy:Longint;		begin			Delay(15,dummy);			FootStop:=False;			While InReady(SPortA) do				begin					GetChar(SPortA,ch);					if  ch = 'S' then						FootStop:=True;				end;		end;	procedure GetStringM(var TheString:str255);		var			ch:char;			i:integer;			A:integer;		begin			thestring:='';			repeat				begin					GetChar(SPortA,ch);					if  ch > chr(32) then						thestring:=concat(thestring,ch);				end;			until ch=chr(10);		end;	procedure SendString(TheString:str255);		var			i:integer;		begin			for i := 1 to Length(TheString) do				sendChar(SPortA,TheString[i]);			sendChar(SPortA,chr(13));			sendChar(SPortA,chr(10));		end;	procedure ReadMicro(var channel1,channel2,channel3:Real;						var	FootStop:Boolean);		var			TheString:str255;			Dummy:boolean;		begin			ClearBuffer(FootStop);			SendString('D1');			getStringM(TheString);			String2Real(TheString,channel1);			SendString('D2');			getStringM(TheString);			String2Real(TheString,channel2);			SendString('D3');			getStringM(TheString);			String2Real(TheString,channel3);			ClearBuffer(dummy);		end;{***********************}	Function Filter(TheDialog:DialogPtr;		var theEvent:EventRecord;		var itemNumber:Integer):			Boolean;		const			returnCode=				13;			enterCode=				3;			CancelCode=				27;			asterCode=				42;		var			charCode:				char;		begin			Filter:=false;			if (theEvent.What = keyDown) or (theEvent.What = AutoKey) then				begin					CharCode:=chr(BitAnd(theEvent.message,charCodeMask));					if BitAnd(theEvent.modifiers,CmdKey) = CmdKey then						begin							case CharCode of								'X':DlgCut(TheDialog);								'C':DlgCopy(TheDialog);								'V':DlgPaste(TheDialog);								'B':DlgDelete(TheDialog);							end;							Filter:=true;						end;					if CharCode = chr(returnCode) then						begin							itemNumber:=OK;							Filter:=true;						end;					if CharCode = chr(CancelCode) then						begin							itemNumber := Cancel;							Filter:=true;						end;					if CharCode = chr(enterCode) then						begin							theEvent.message:=theEvent.message+6;							Filter:=false;						end;					if CharCode = chr(asterCode) then						begin							itemNumber:=3;							Filter:=true;						end;				end;			{if inReady(SPortA) then				begin					itemNumber:=99;					Filter:=True;				end;}		end;{*********************}	procedure GetHeaderDialog(DialogPointer:DialogPtr);		var			i:integer;		begin			Header.Beam:=GetDlgStr(8,DialogPointer);			Header.Date:=GetDlgStr(9,DialogPointer);			Header.Event:=GetDlgStr(10,DialogPointer);			Header.Operator:=GetDlgStr(11,DialogPointer);			Header.Plate:=GetDlgStr(12,DialogPointer);			Header.Part:=GetDlgStr(13,DialogPointer);			Header.Rangetostar:=GetDlgStr(14,DialogPointer);			Header.ShrinkFactZT:=GetReal(15,DialogPointer);			Header.ShrinkFactZM:=GetReal(16,DialogPointer);			Header.Magnification:=GetReal(17,DialogPointer);			Header.ZZO:=GetReal(18,DialogPointer);			for i:=1 to 4 do				begin					Header.NB[i]:=GetDlgInt(19+(i-1)*4,DialogPointer);					Header.G1[i]:=GetDlgInt(20+(i-1)*4,DialogPointer);					Header.G2[i]:=GetDlgInt(21+(i-1)*4,DialogPointer);					Header.G3[i]:=GetDlgInt(22+(i-1)*4,DialogPointer);				end;			Header.Primary:=GetDlgStr(35,DialogPointer);			Header.Frag:=GetDlgStr(36,DialogPointer);			Header.a:=GetDlgStr(37,DialogPointer);			Header.p:=GetDlgStr(38,DialogPointer);			Header.M:=GetDlgStr(39,DialogPointer);			for i:=1 to 4 do				begin					Header.X[i]:=GetReal(40+(i-1)*3,DialogPointer);					Header.Z[i]:=GetReal(41+(i-1)*3,DialogPointer);					Header.Y[i]:=GetReal(42+(i-1)*3,DialogPointer);				end;		end;	procedure SetHeaderDialog(DialogPointer:DialogPtr);		var			i:integer;		begin			SetDlgStr(8,Header.Beam,DialogPointer);			SetDlgStr(9,Header.Date,DialogPointer);			SetDlgStr(10,Header.Event,DialogPointer);			SetDlgStr(11,Header.Operator,DialogPointer);			SetDlgStr(12,Header.Plate,DialogPointer);			SetDlgStr(13,Header.Part,DialogPointer);			SetDlgStr(14,Header.Rangetostar,DialogPointer);			SetReal(15,Header.ShrinkFactZT,3,DialogPointer);			SetReal(16,Header.ShrinkFactZM,3,DialogPointer);			SetReal(17,Header.Magnification,3,DialogPointer);			SetReal(18,Header.ZZO,3,DialogPointer);			for i:=1 to 4 do				begin					SetDlgInt(19+(i-1)*4,Header.NB[i],DialogPointer);					SetDlgInt(20+(i-1)*4,Header.G1[i],DialogPointer);					SetDlgInt(21+(i-1)*4,Header.G2[i],DialogPointer);					SetDlgInt(22+(i-1)*4,Header.G3[i],DialogPointer);				end;			SetDlgStr(35,Header.Primary,DialogPointer);			SetDlgStr(36,Header.Frag,DialogPointer);			SetDlgStr(37,Header.a,DialogPointer);			SetDlgStr(38,Header.p,DialogPointer);			SetDlgStr(39,Header.M,DialogPointer);			for i:=1 to 4 do				begin					SetReal(40+(i-1)*3,Header.X[i],2,DialogPointer);					SetReal(41+(i-1)*3,Header.Z[i],2,DialogPointer);					SetReal(42+(i-1)*3,Header.Y[i],2,DialogPointer);				end;			SetReal(52,Header.ShrinkFactAN,3,DialogPointer);			SetReal(53,Header.SlopeXY,2,DialogPointer);			SetReal(54,Header.SlopeZY,2,DialogPointer);			SetDlgint(55,Header.NHtotal,DialogPointer);			SetReal(56,Header.EnergyTotal,2,DialogPointer);			SetReal(57,Header.FtoBBlack,2,DialogPointer);			SetReal(58,Header.FtoBGrey,2,DialogPointer);		end;	Procedure HeaderDefault;		var			seconds:longint;			dummy:str255;		begin			if Header.Date = '' then				begin					getdatetime(seconds);					IUDateString(seconds,shortDate,Dummy);					Header.Date:=Dummy;				end;		end;	procedure SetParticleDialog(var Particle:ParticleType;			DialogPointer:DialogPtr);		begin			SetDlgStr(6,Particle.Number,DialogPointer);			setReal(7,Particle.GrainCount,1,DialogPointer);			SetReal(8,Particle.xsec,1,DialogPointer);			SetReal(9,Particle.zsec,1,DialogPointer);			SetReal(10,Particle.ysec,3,DialogPointer);			SetReal(11,Particle.xstar,2,DialogPointer);			SetReal(12,Particle.zstar,2,DialogPointer);			SetReal(13,Particle.ystar,3,DialogPointer);			SetReal(14,Particle.pseudo,3,DialogPointer);			SetReal(15,Particle.BigX,1,DialogPointer);			SetReal(16,Particle.BigZ,1,DialogPointer);			SetReal(17,Particle.deltaX,4,DialogPointer);			SetReal(18,Particle.deltaY,4,DialogPointer);			SetReal(19,Particle.deltaZ,4,DialogPointer);			SetReal(20,Particle.deltaR,4,DialogPointer);			SetReal(21,Particle.Beta,2,DialogPointer);			SetReal(22,Particle.degrees,2,DialogPointer);			SetReal(23,Particle.azimuth,1,DialogPointer);			SetReal(24,Particle.azidegree,1,DialogPointer);		end;	procedure GetParticleDialog(var Particle:ParticleType;					DialogPointer:DialogPtr);		begin			Particle.Number:=GetDlgStr(6,DialogPointer);			Particle.GrainCount:=GetReal(7,DialogPointer);			Particle.xsec:=GetReal(8,DialogPointer);			Particle.zsec:=GetReal(9,DialogPointer);			Particle.ysec:=GetReal(10,DialogPointer);			Particle.xstar:=GetReal(11,DialogPointer);			Particle.zstar:=GetReal(12,DialogPointer);			Particle.ystar:=GetReal(13,DialogPointer);		end;	procedure DefaultParticle(var Particle:ParticleType);		var			LastParticle:ParticleType;			NoSelect:Boolean;		begin			if Header.NumParticle > 0 then				begin					CleanParticle(LastParticle);					GetLastParticle(LastParticle,NoSelect);					Particle.Xstar:=LastParticle.Xstar;					Particle.Ystar:=LastParticle.Ystar;					Particle.Zstar:=LastParticle.Zstar;					Particle.ysec:=LastParticle.ysec;				end;		end;	procedure NullButton(			ItemHit				:integer;		var			Done,			Cancel				:Boolean;			DialogPointer				:DialogPtr);		begin			case itemHit of				1:	Done:=true;				2:	begin							done:=true;							cancel:=true;						end;			end;		end;	procedure HeaderButton(			ItemHit				:integer;		var			Done,			Cancel				:Boolean;			DialogPointer				:DialogPtr);		begin			case itemHit of				1:	Done:=true;				2:	begin							done:=true;							cancel:=true;						end;				3:	begin							GetHeaderDialog(DialogPointer);							CalcHeader(Header);							SetHeaderDialog(DialogPointer);						end;			end;		end;	procedure ParticleButton(			ItemHit				:integer;		var			Done,			Cancel				:Boolean;			DialogPointer				:DialogPtr);		var			DumbParticle:				ParticleType;			channel1,			channel2,			channel3:				Real;			footstop:				Boolean;		begin			case itemHit of				1:	Done:=true;				2:	begin							done:=true;							cancel:=true;						end;				3:	begin							GetParticleDialog(DumbParticle,DialogPointer);							CalcParticle(DumbParticle,Header);							SetParticleDialog(DumbParticle,DialogPointer);						end;				99:	begin							ReadMicro(channel1,channel2,channel3,FootStop);							if FootStop then								done:=true;							SetReal(4,channel1,2,dialogPointer);							SetReal(5,channel2,2,dialogPointer);							SetReal(6,channel3,2,dialogPointer);							ClearBuffer(FootStop);						end;			end;		end;	Procedure Modal(		var			cancel:				Boolean;			button:				Integer;			DialogPointer:				DialogPtr);		Var			itemHit:				integer;			Done:				boolean;  	begin  		cancel:=false;  		done:=false;        repeat					begin {repeat}						ModalDialog(@Filter,itemHit);						case Button of							1:	NullButton(ItemHit,Done,Cancel,DialogPointer);							2:	ParticleButton(ItemHit,Done,Cancel,DialogPointer);							3:	HeaderButton(ItemHit,Done,Cancel,DialogPointer);						end;					end;{repeat}				until done;    end;{dialog}	procedure HeaderDialog(var cancel:boolean);		var			DialogPointer:DialogPtr;		begin			DialogPointer:=GetNewDialog(HeaderLTRes,nil,pointer(-1));			SetHeaderDialog(dialogPointer);			Modal(Cancel,3,DialogPointer);			if not cancel then				begin					GetHeaderDialog(DialogPointer);					CalcHeader(Header);				end;			CloseDialog(DialogPointer);		end;    procedure ParticleDialog(	var Particle		:ParticleType;    										var Cancel		:Boolean);    var			DialogPointer:DialogPtr;		begin			DialogPointer:=GetNewDialog(ParticleLTRes,nil,pointer(-1));			SetParticleDialog(Particle,DialogPointer);			Modal(Cancel,2,DialogPointer);			if not cancel then				begin					GetParticleDialog(Particle,DialogPointer);					CalcParticle(particle,header);				end;			CloseDialog(DialogPointer);		end;{*******************}	procedure DebugDialog{(TheInteger:integer)};		var			cancel:boolean;			DialogPointer:DialogPtr;			ItemType		:integer;			TextHandle		:Handle;			Box					:rect;			itemHit	:integer;			TheString:str255;		begin			DialogPointer:=GetNewDialog(DebugRes,nil,pointer(-1));			NumToString(TheInteger,TheString);			GetDItem(DialogPointer,3,ItemType,TextHandle,Box);			SetItext(TextHandle,TheString);			ModalDialog(nil,itemHit);			CloseDialog(DialogPointer);		end;	procedure AreYouSure(	TheString	:Str255;											var cancel	:boolean);		var			DialogPointer:DialogPtr;		begin			DialogPointer:=GetNewDialog(AreSureRes,nil,pointer(-1));			SetDlgStr255(3,TheString,DialogPointer);			Modal(Cancel,1,DialogPointer);			CloseDialog(DialogPointer);		end;{**********************}	procedure ProcessMenu(CodeWord : LongInt);		var			menuNum : Integer;			itemNum : Integer;{***********************}		procedure DoAppleMenu;			procedure About;				var					AboutRecord : DialogRecord;					AboutDlog : DialogPtr;					dummy:integer;				begin					AboutDlog := GetNewDialog(AboutRes,nil,Pointer(-1));					ModalDialog(nil,dummy);					CloseDialog(AboutDlog);				end;			procedure DeskAccesory;				var					dummy:integer;					nameHolder : str255;				begin					GetItem(myMenus[appleMenu],ItemNum,NameHolder);					dummy := OpenDeskAcc(NameHolder);				end;			begin				case ItemNum of					1:About;					2 :;					otherwise						deskAccesory;				end;			end;{*****************}		procedure DoEditMenu;			begin				if not SystemEdit(ItemNum - 1) then					begin						case ItemNum of						end;					end;			end;{*****************}		procedure DoFileMenu;			{procedures for file menu}			Procedure DrawPage(var AllDone:Boolean;				Page:Integer);				begin				end;			procedure NewList;				var					CSize:Point;					DataBounds,rview:Rect;					len:integer;					ParticlePointer:ParticlePtr;					Last:Cell;					i:integer;				begin					if InMem then						begin							for i := 1 to Header.NumParticle do								begin									len:=SizeOf(ParticlePointer);									last.h:=0;									Last.v:=i-1;									LGetCell(pointer(ord(@ParticlePointer)),Len,Last,List);									Dispose(ParticlePointer);								end;							LDispose(List);							CloseWindow(listWindow);						end;					ListWindow:=GetNewWindow(300,nil,Pointer(-1));					SetPort(ListWindow);					Databounds.top:=0;					DataBounds.Left:=0;					DataBounds.Bottom:=0;					DataBounds.Right:=1;					Rview:=ListWindow^.PortRect;					Rview.right:=Rview.right-16;					Rview.Bottom:=Rview.Bottom-16;					Rview.Top:=Rview.Top+10+80;					CSize.v:=10;					CSize.h:=(50*9)+25;					List:=Lnew(Rview,databounds,cSize,0,Listwindow,false,false,true,true);					List^^.ListDefProc:=NewHandle(0);					List^^.ListDefProc^:=ptr(@MyListDef);					List^^.selFlags:=lOnlyOne;					LDoDraw(true,List);				end;			procedure FileError;				var					TheError:str255;  				begin  					if IOR > 0 then  						begin  							GetErrorMessage(IOR,TheError);  							sysbeep(5);  							DebugDialog(IOR);  						end;  				end;			procedure ReadFile(Reply:SFReply);				var					f:filerec;					i:integer;					Particle:ParticleType;					Temp:Integer;				begin					FReset(f,reply.vRefNum,reply.fName);					FGetM(f,@Header,SizeOf(Header));					Header.Reply:=Reply;					Temp:=Header.NumParticle;					newlist;					Header.NumParticle:=0;					SetWTitle(ListWindow,Header.reply.fName);					for i := 1 to Temp do						begin							FGetM(f,@Particle,SizeOf(Particle));							AddParticle(Particle);						end;					FClose(f);					FileError;				end;			procedure WriteFile(Reply:SFReply);				var					f:FileRec;					Particle:ParticleType;					len:integer;					Last:Cell;					I:integer;					ParticlePointer:ParticlePtr;				begin 					FRewrite(f,reply.vRefNum,reply.fName,'DATA','MICR');					FPutM(f,@Header,SizeOf(Header));					len:=SizeOf(ParticlePointer);					last.h:=0;					SetWTitle(ListWindow,Header.reply.fName);					for i := 1 to Header.NumParticle do						begin							Last.v:=i-1;							LGetCell(pointer(ord(@ParticlePointer)),Len,Last,List);							Particle:=ParticlePointer^;							FPutM(f,@Particle,SizeOf(Particle));						end;					FClose(f);					FileError;				end;			procedure GetReadFile(var reply:SFReply);				var					pt:point;					FileType:SFTypeList;				begin					pt.h:=50;					pt.v:=50;					FileType[0][1]:='D';					FileType[0][2]:='A';					FileType[0][3]:='T';					FileType[0][4]:='A';					SFGetFile(pt,'Enter File',nil,1,filetype,nil,reply);				end;			procedure GetWriteFile(var reply:SFReply);				var					pt:point;				begin					pt.h:=50;					pt.v:=50;					SFPutFile(pt,'Save File',Reply.Fname,nil,reply);				end;			{the File menu procedures}			procedure NewFile;				var					cancel:boolean;				begin					if changed and InMem then						AreYouSure('Are you sure you want to throw away Changes to this file?',Cancel);					if not cancel then						begin							CleanHeader;							HeaderDefault;							HeaderDialog(Cancel);							NewList;							Header.Reply.FName:='untitled';							SetWTitle(ListWindow,Header.reply.fName);							Header.NumParticle:=0;							changed:=True;							InMem:=True;							FromFile:=False;						end;				end;			procedure OpenFile;				var					Cancel:Boolean;				begin					if inmem and Changed then						AreYouSure('Are you sure you want to throw away Changes to this file?',Cancel);					if not cancel then						begin							GetReadFile(Header.Reply);							if  Header.Reply.good then								begin									ReadFile(Header.Reply);									Changed:=false;									InMem:=True;									fromFile:=true;								end;						end;				end;			Procedure CloseFile;				var					cancel:Boolean;				begin					if Changed and inmem then						AreYouSure('Are you sure you want to throw away Changes to this file?',Cancel);					if not cancel then						begin							LDispose(List);							DisposeWindow(listWindow);							InMem:=False;							changed:=False;							FromFile:=False;						end;				end;			Procedure SaveAsFile;				begin					GetWriteFile(Header.Reply);					if Header.Reply.Good then						begin							WriteFile(Header.Reply);							Changed:=False;							FromFile:=true;						end;				end;			Procedure SaveFile;				begin					WriteFile(Header.Reply);					Changed:=False;					FromFile:=true;				end;			Procedure RevertFile;				var					cancel:Boolean;				begin					if Changed and inmem then						AreYouSure('Are you sure you want to throw away Changes to this file?',Cancel);					if not cancel then						begin							NewList;							ReadFile(Header.Reply);							Changed:=False;							InMem:=True;							fromFile:=true;						end;				end;			Procedure AppendFile;				Var					Reply:SFReply;					F:Text;					Last:Cell;					Particle:ParticleType;					i:integer;					len:integer;					ParticlePointer:ParticlePtr;				Const					Wide=10;				begin					GetWriteFile(Reply);					Open(F,Reply.FName);					Rewrite(F);					with Header Do						begin							writeln(F,NumParticle:Wide); 							writeln(F,slopexy:Wide:3); 							writeln(F,slopezy:Wide:3); 							writeln(F,Event:Wide); 							writeln(F,Date:Wide); 							writeln(F,operator:Wide); 							writeln(F,ShrinkFactZT:Wide:2); 							writeln(F,ShrinkFactZM:Wide:3); 							writeln(F,Magnification:Wide:2); 							writeln(F,ZZO:Wide:2); 							writeln(F,X[1]:Wide:3,chr(9),Y[1]:Wide:3,chr(9),Z[1]:Wide:3); 							writeln(F,X[2]:Wide:3,chr(9),Y[2]:Wide:3,chr(9),Z[2]:Wide:3); 							writeln(F,X[3]:Wide:3,chr(9),Y[3]:Wide:3,chr(9),Z[3]:Wide:3); 							writeln(F,X[4]:Wide:3,chr(9),Y[4]:Wide:3,chr(9),Z[4]:Wide:3); 							writeln(F,Beam:Wide); 							writeln(F,Plate:Wide); 							writeln(F,part:Wide); 							writeln(F,Rangetostar:Wide); 							writeln(F,Primary:Wide); 							writeln(F,Frag:Wide); 							writeln(F,a:Wide); 							writeln(F,p:Wide); 							writeln(F,M:Wide); 							writeln(F,NHtotal:Wide); 							writeln(F,FBL:Wide); 							writeln(F,G1:Wide); 							writeln(F,BBL:Wide); 							writeln(F,G2:Wide); 							writeln(F,ShrinkFactAN:Wide:3); 							writeln(F,dipofprimary:Wide:3); 							Writeln(F); 						end;					last.h:=0;					len:=SizeOf(Particle);					for i := 1 to Header.NumParticle do						begin							Last.v:=i-1;							LGetCell(pointer(ord(@Particle)),Len,Last,List);							with particle do								begin									write(F,Number:Wide,Chr(9)); 									write(F,xsec:Wide:3,Chr(9)); 									write(F,ysec:Wide:3,Chr(9)); 									write(F,zsec:Wide:3,Chr(9)); 									write(F,GrainCount:Wide:3,Chr(9)); 									write(F,P:Wide:3,Chr(9)); 									write(F,L:Wide:3,Chr(9));									write(F,beta:Wide:3,Chr(9));									write(F,degrees:Wide:3,Chr(9));									write(F,azimuth:Wide:3,Chr(9));									write(F,azidegree:Wide:3,Chr(9));									write(F,pseudo:Wide:3,Chr(9));									write(F,deltax:Wide:3,Chr(9));									write(F,deltay:Wide:3,Chr(9));									write(F,deltaz:Wide:3,Chr(9));									write(F,bigx:Wide:3,Chr(9));									write(F,bigz:Wide:3,Chr(9));									write(F,deltar:Wide:3,Chr(9));									write(F,xstar:Wide:3,Chr(9));									write(F,ystar:Wide:3,Chr(9));									writeln(F,zstar:Wide:3);								end;						end;					Close(F);				end;			Procedure PageSetUp;				var					trueORfalse : boolean;				begin  					trueORfalse := PrValidate(PgSetUp);					trueORfalse := PrStlDialog(PgSetUp);				end;			Procedure PrintFile;				var					Cancel,					AllDone:						Boolean;					Page:						integer;				begin					Cancel:=False;					Page:=1;					While Not Cancel do						begin							if PrJobDialog(PgSetup) then								begin									Cancel:=False;									PrinterPort:=PrOpenDoc(PgSetup,nil,nil);									allDone:=False;									PrOpenPage(PrinterPort,nil);									DrawPage(AllDone,Page);									Page:=Page+1;									PrClosePage(PrinterPort);									PrCloseDoc(PrinterPort);									PrPicFile(PgSetup,nil,nil,nil,myStRec);								end							else								Cancel:=True;						end;				end;			Procedure QuitProgram;				var					cancel:Boolean;				begin					if Changed and inmem then						AreYouSure('Are you sure you want to throw away Changes to this file?',Cancel);					if not cancel then						Done:=True;				end;			begin				case ItemNum of					1:NewFile;					2:OpenFile;					3:CloseFile;					4:;					5:SaveFile;					6:SaveAsFile;					7:RevertFile;					8:;					9:AppendFile;					10:;					11:PageSetUp;					12:PrintFile;					13:;					14:QuitProgram;				end;				DrawMenu;			end;{******************}		procedure DoParticleMenu;			procedure NewParticle(var Cancel:Boolean);				var					particle:ParticleType;				begin					CleanParticle(Particle);					DefaultParticle(Particle);					ParticleDialog(Particle,cancel);					if not cancel then						begin							AddParticle(Particle);							Changed:=true;						end;				end;			procedure AddParticleMenu;				var					cancel:boolean;				begin					NewParticle(Cancel);				end;			procedure AddContinuousParticle;				var					cancel:boolean;				begin					repeat						NewParticle(Cancel);					until cancel;				end;			procedure EditParticle;				var					cancel,NoSelect:boolean;					Particle:ParticleType;				begin					GetParticle(Particle,NoSelect);					if not NoSelect then						begin							ParticleDialog(Particle,cancel);							if not cancel then								begin									SetParticle(Particle,NoSelect);									Changed:=true;								end;						end;				end;			procedure ClearParticle;				var					particle:ParticleType;					NoSelect:Boolean;				begin					GetParticle(Particle,NoSelect);					if not NoSelect then						begin							CleanParticle(Particle);							SetParticle(Particle,NoSelect);							Changed:=true;						end;				end;			procedure DeleteParticleMenu;				var					noSelect:Boolean;				begin					DeleteParticle(NoSelect);					if Not NoSelect then						changed:=true;				end;			begin				case ItemNum of					1:AddParticleMenu;					2:AddContinuousParticle;					3:EditParticle;					4:ClearParticle;					5:DeleteParticleMenu;				end;				DrawMenu;			end;{****************}		procedure DoHeaderMenu;			procedure EditHeader;				var					cancel:boolean;				begin					HeaderDialog(Cancel);					if not cancel then						Changed:=true;				end;			Procedure ClearHeader;				begin					CleanHeader;					changed:=true;				end;			begin				case ItemNum of					1:EditHeader;					2:ClearHeader;				end;				DrawMenu;			end;{*****************}		begin			menuNum := HiWord(CodeWord);			itemNum := LoWord(CodeWord);			if itemNum > 0 then				begin					case MenuNum of						1:DoAppleMenu;						2:DoFileMenu;						3:DoEditMenu;						4:DoParticleMenu;						5:DoHeaderMenu;					end;				end;			HiliteMenu(0);		end;{******************}	procedure AllDone;		begin			CloseSPort(sPortA);			PrClose;		end;{******************}	procedure MainEventLoop;		var			Event : EventRecord;			windowLoc : integer;			mouseLoc : point;			theWindow:WindowPtr;			CharCode : Char;			DummyBoolean : Boolean;			Last:Cell;			box:rect;			thestring:str255;		begin			repeat				SystemTask;				if InMem then					begin						Last.v:=0;						Last.h:=0;						if not LGetSelect(true,Last,List) then							begin								Last.v:=0;								Last.h:=0;								LSetSelect(True,last,List);							end;					end;				if GetNextEvent(everyEvent,Event) then					begin						case event.what of							mouseDown :								begin									mouseLoc := Event.where;									windowLoc := FindWindow(mouseLoc,theWindow);									case windowLoc of										inMenuBar :											ProcessMenu(MenuSelect(MouseLoc));										inSysWindow:											SystemClick(Event,theWindow);										inContent:											begin												GlobalToLocal(MouseLoc);												DummyBoolean := LClick(MouseLoc, Event.modifiers,List);											end;										inDrag:											begin												DragWindow(theWindow,mouseLoc,DragArea);												SelectWindow(theWindow);											end;										inGrow:											begin												GlobalToLocal(MouseLoc);												DummyBoolean := LClick(MouseLoc, Event.modifiers,List);											end;										inGoAway:											begin											end;										inDesk:											Begin											end;									end;								end;							UpdateEvt :								begin									BeginUpdate(ListWindow);									List^^.listdefProc^ := Ptr(@MyListDef);									LUpdate(ListWindow^.visRgn,List);									textfont(4);									textSize(9);									SetRect(Box,0,0+80,25,10+80);									TheString:='#';									TextBox(POINTER(ORD(@theString)+1),Length(theString),Box,TEJustRight);									SetRect(Box,0+25,0+80,50+25,10+80);									TheString:='X';									TextBox(POINTER(ORD(@theString)+1),Length(theString),Box,TEJustRight);									setRect(Box,50+25,0+80,100+25,10+80);									TheString:='Z';									TextBox(POINTER(ORD(@theString)+1),Length(theString),Box,TEJustRight);									setRect(Box,100+25,0+80,150+25,10+80);									TheString:='Y';									TextBox(POINTER(ORD(@theString)+1),Length(theString),Box,TEJustRight);									setRect(Box,150+25,0+80,200+25,10+80);									TheString:='Ident';									TextBox(POINTER(ORD(@theString)+1),Length(theString),Box,TEJustRight);									setRect(Box,200+25,0+80,250+25,10+80);									TheString:='Grain';									TextBox(POINTER(ORD(@theString)+1),Length(theString),Box,TEJustRight);									setRect(Box,250+25,0+80,300+25,10+80);									TheString:='Pseudo';									TextBox(POINTER(ORD(@theString)+1),Length(theString),Box,TEJustRight);									setRect(Box,300+25,0+80,350+25,10+80);									TheString:='Big X';									TextBox(POINTER(ORD(@theString)+1),Length(theString),Box,TEJustRight);									setRect(Box,350+25,0+80,400+25,10+80);									TheString:='Big Z';									TextBox(POINTER(ORD(@theString)+1),Length(theString),Box,TEJustRight);									setRect(Box,400+25,0+80,450+25,10+80);									TheString:='phi';									TextBox(POINTER(ORD(@theString)+1),Length(theString),Box,TEJustRight);									EndUpdate(ListWindow);								end;							ActivateEvt :								begin									LActivate(Odd(Event.modifiers),List);									InvalRect(ListWindow^.PortRect);								end;							keyDown,AutoKey :								begin									CharCode := chr(BitAnd(Event.message,charCodeMask));									if BitAnd(Event.modifiers,CmdKey) = CmdKey then										ProcessMenu(MenuKey(CharCode));								end;						end;					end;			until Done;		end;{**************************}	procedure InitThings;		procedure SetupLimits;			var				Screen : Rect;			begin				Screen := ScreenBits.bounds;				with Screen do					begin						SetRect(DragArea,left+4,top+24,right-4,bottom-4);						SetRect(GrowArea,left,top+24,right,bottom);					end;			end;		procedure SetUpMenus;				var					index : integer;			begin				for index := beginMenu to endMenu do					myMenus[index] := GetMenu(index);				AddResMenu(myMenus[appleMenu],'DRVR');				for index := beginMenu to endMenu do					InsertMenu(myMenus[index],0);				DrawMenu;			end;		procedure SetUpPort;			var				Dummy:integer;			begin				Dummy:=InitSPort(SPortA,baud2400,stop10,noParity,data7,1000,xOnXOff,xOnXOff);				SendString('SON');				SetBufSize(1000);			end;		procedure SetUpFile;			begin				SetBufSize(32769*2);			end;		procedure SetupMemory;			var				x : Longint;			begin				x := ORD4(ApplicZone) + 384000;				SetApplLimit(Pointer(x));				MaxApplZone;				MoreMasters;				MoreMasters;				MoreMasters;				MoreMasters;				MoreMasters;				MoreMasters;			end;		procedure SetupPrinter;			var				DumPageSetup:					TPrint;			begin				prOpen;				PgSetUp:=THPrint(NewHandle(SizeOf(DumPageSetup)));				PrintDefault(PgSetUp);				HLock(Handle(PgSetUp));			end;		begin			Done:=False;			InMem:=False;			Changed:=False;			FromFile:=False;			FlushEvents(everyEvent,0);			InitGraf(@thePort);			InitFonts;			InitWindows;			InitMenus;			TEInit;			InitDialogs(nil);			InitCursor;			InitAllPacks;			SetupLimits;			SetUpMemory;			SetUpMenus;			SetupPrinter;			SetUpPort;			SetupFile		end;{***********************}	begin		initThings;		MainEventLoop;		AllDone;	end.