 program Micro;  	{$B+}  	{$R+}  	{$T APPL MICR}	{$L MicroRsrc}	{$I TML:Library:MemTypes.ipas}	{$I TML:Library:QuickDraw.ipas}	{$I TML:Library:OSIntf.ipas}	{$I TML:Library:ToolIntf.ipas}	{$I TML:Library:PackIntf.ipas}	{$I TML:Library:ListMgrIntf.ipas}	{$I TML:Library:MacPrint.ipas}	{$I TML:Library:FileIo.iPas}	{$I TML:Library:Serial.iPas}	type		{My Types}		arr4=array[1..4] of real; 		HeaderType= 			packed record 				Reply:SfReply; 				NumParticle:Integer; 				 				slopexy:real; 				slopezy:real; 				Event:str255; 				Date:str255; 				operator:str255; 				ShrinkFactZT:Real; 				ShrinkFactZM:Real; 				Magnification:Real; 				ZZO:Real; 				X:arr4; 				y:arr4; 				z:arr4; 				Beam:str255; 				Plate:str255; 				part:str255; 				Rangetostar:str255; 				Primary:str255; 				Frag:str255; 				a:str255; 				p:str255; 				M:str255; 				NH:str255; 				FBL:str255; 				G1:str255; 				BBL:str255; 				G2:str255; 				ShrinkFactAN:Real; 				dipofprimary:real; 			end; 		ParticleType= 			packed record 				Number:Str255; 				xsec:real; 				ysec:Real; 				zsec:real; 				GrainCount:real; 				P:Real; 				L:real; 				Fate:str255;				beta:real;					{beta}				degrees:real;				{beta expressed in degrees}				azimuth:real;				{azimuth angle}				azidegree:real;			{azimuth angle expressed in degress}				pseudo:real;				{pseudoripidity}									{slope of children particles with respect to the primary}				deltax:real;						{the value calculated from the raw data}				deltay:real;						{the value calculated from the raw data}				deltaz:real;                         {the value calculated from the raw data}				bigx:real; 				bigz:real;				deltar:real;				xstar:real;				ystar:real;				zstar:real;			end;	const		HeaderNHRes=			6000;		ParticleNHRes=			6001;		DebugRes=			6002;		AreSureRes=			6003;		AboutRes=			6004;		HeaderLTRes=			6005;		ParticleLTRes=			6006;		appleMenu =			300;		fileMenu =			301;		editMenu =			302;		particleMenu =			303;		HeaderMenu =			304;		beginMenu =			300;		endMenu =			304;		pi=			3.1415926535898;		DecAcc=			4;	var		{Mac Varibles}		Done:			Boolean;		myMenus:			 array[beginMenu..endMenu] of MenuHandle;		DragArea,		GrowArea:			Rect;		PgSetUp:			THPrint;		{My Global Varibles}				InMem,		FromFile,		changed:			Boolean;		Header:			HeaderType;		List:			ListHandle;		ListWindow:			WindowPtr;		DialogPointer			:DialogPtr;{********************}	procedure DebugDialog(	theString:str255;    											theReal:Real;    											TheInteger:integer);    	forward;{****************************************************}    		procedure calcheader;			{Michael Heinrich}		{8/20/86}		{The purpose of this program is to }		{calculate theta, psi,pseudoripidity}		{for particles given a primary and secondary}		{measurements on the particles}		{this is only part of the overall developement}		{the input and output of data will be handled}		{by other parts of the program}		{print option not on disk}		{calculates the dip of the primary}		var				j:integer;{indice counter throughout}				partialdip:real;{partial sum of dip}				K:integer;		begin{calprimary}			with header do				begin					partialdip:=0;					k:=4;					for j:=k downto 2 do						partialdip:=((x[j]-x[j-1])/(y[j]-y[j-1]))+partialdip;					slopexy :=(partialdip/((k-1)*1000))*(Magnification);					partialdip:=0;					if Header.ShrinkFactZM<>0 then				   	 Header.ShrinkFactAN:=Header.ShrinkFactZT/Header.ShrinkFactZM;					for j:=k downto 2 do						partialdip:=((z[j]-z[j-1])/(y[j]-y[j-1]))+partialdip;					slopezy :=(partialdip/((k-1)*1000))*(ShrinkFactAN);				end;		end;{calprimary}	procedure calcparticle(var particle:particletype;header:headertype);		procedure changeofxyz(var particle:particletype;header:headertype);			begin{ changeofxyz}				with particle do					begin						deltay:=(ysec-particle.ystar)*1000;						deltax:=(xsec-particle.xstar)*(header.Magnification)-(header.slopexy*deltay);						deltaz:=(zsec-particle.zstar)*(header.ShrinkFactAN)-(header.slopezy*deltay);					end;  			 end;{ changeofxyz}  		procedure answer(var particle:particletype);       	procedure beta(var particle:particletype);       					{calculates beta}          				begin          			with particle do         				begin            				beta:=arctan(sqrt(sqr(deltax)+sqr(deltaz))/abs(deltay));            		 		If deltay>0 then             					beta:= pi+(-beta);             				degrees:=beta*180/pi;             			end;            				end;			procedure pseudoripidity(var particle:particletype);							{calculates pseudoripidity}								begin             		particle.pseudo:=-ln(abs(sin(particle.beta/2)/cos(particle.beta/2)));          		end;			procedure azimuthangle(var particle:particletype);							{calculates azimuth angle}								begin					with particle do						begin							if deltaz=0 then								azimuth:=(pi/2)							else							 	azimuth:=arctan(abs(deltax/deltaz));							if deltaz<>0 then								begin									if abs(deltax/deltaz)<>(deltax/deltaz) then										azimuth:=-azimuth;								end							else								if deltax<0 then									azimuth:=-azimuth;							if deltaz>=0 then								begin									if deltax<0 then										azimuth:=azimuth+2*pi;								end							else								azimuth:=azimuth+pi;							azidegree:=azimuth*180/pi;						end;				end;			procedure calcxandz(var particle:particletype);				begin{calcxandz}					with particle do						begin							deltar:=1000*sin(beta)/cos(beta);							bigx:=deltar*sin(azimuth);							bigz:=deltar*cos(azimuth);						end;				end;{calcxandz}			begin{answer}				beta(particle);				pseudoripidity(particle);				azimuthangle(particle);				calcxandz(particle);				end;{answer}		begin{calcparticle}			changeofxyz(particle,header);			answer(particle);		end;{calcparticle}{********************************************}	  	procedure NoFileMenu;  		begin  			Enableitem(MyMenus[appleMenu],0);  			Enableitem(MyMenus[appleMenu],1);  			Enableitem(MyMenus[fileMenu],0);  			Enableitem(MyMenus[fileMenu],1);  			Enableitem(MyMenus[fileMenu],2);  			DisableItem(MyMenus[fileMenu],3);			DisableItem(MyMenus[fileMenu],5);			DisableItem(MyMenus[fileMenu],6);			DisableItem(MyMenus[fileMenu],7);			DisableItem(MyMenus[fileMenu],9);			EnableItem(MyMenus[fileMenu],11);			DisableItem(MyMenus[fileMenu],12);			EnableItem(MyMenus[fileMenu],14);			DisableItem(MyMenus[ParticleMenu],0);			DisableItem(MyMenus[HeaderMenu],0);  		end;  	procedure NewMenuNone;  		begin  			NoFileMenu;  			EnableItem(MyMenus[FileMenu],3);			EnableItem(MyMenus[FileMenu],6);			EnableItem(MyMenus[FileMenu],9);			EnableItem(MyMenus[FileMenu],12);			EnableItem(MyMenus[ParticleMenu],0);			EnableItem(MyMenus[ParticleMenu],1);			EnableItem(MyMenus[ParticleMenu],2);			DisableItem(MyMenus[Particlemenu],3);			DisableItem(MyMenus[ParticleMenu],4);			DisableItem(MyMenus[ParticleMenu],5);			Enableitem(MyMenus[HeaderMenu],0);			Enableitem(MyMenus[HeaderMenu],1);			Enableitem(MyMenus[HeaderMenu],2);  		end;  	procedure NewMenuSome;  		begin  			NewMenuNone;  			EnableItem(MyMenus[ParticleMenu],3);  			EnableItem(MyMenus[ParticleMenu],4);			EnableItem(MyMenus[ParticleMenu],5);  		end;  	procedure OldMenuNone;  		begin			NewMenuNone;			EnableItem(MyMenus[FileMenu],5);			EnableItem(MyMenus[FileMenu],7);  		end;  	procedure OldMenuSome;  		begin  			OldMenuNone;  			EnableItem(MyMenus[ParticleMenu],3);  			EnableItem(MyMenus[ParticleMenu],4);			EnableItem(MyMenus[ParticleMenu],5);  		end;  	procedure DrawMenu;  		begin  			if InMem then  				if fromFile then  					if Header.NumParticle = 0 then  						OldMenuNone  					else  						OldMenuSome  				else  					if Header.NumParticle = 0 then  						NewMenuNone  					else  						NewMenuSome  			else  				NoFileMenu;  			DrawMenuBar;  		end;  {************************}	function Power10 (Expo : integer) : longint;		var			power : longint;			i : integer;		begin			power := 1;			if power <> 0 then				for i := 1 to expo do			power := Power * 10;			power10 := Power;		end;	procedure RealToString (var WholeNumber : Real;		var TheString : Str255);		var			integerPart, decimalPart : str255;		begin			numToString(trunc(abs(wholeNumber)), IntegerPart);			if wholeNumber<0 then				IntegerPart:=concat('-',IntegerPart);			numToString(round(abs(wholeNumber - trunc(wholeNumber)) * power10(DecAcc)), decimalPart);			TheSTring := concat(IntegerPart, '.', copy('000000', 1, DecAcc - length(DecimalPart)), decimalPart);		end;	procedure StringToReal (var WholeNumber : str255;		var TheReal : real);		var			decimalPos : integer;			IntegerPart : longint;			DecimalPart : longint;			zeros : integer;			neg:integer;		begin			DecimalPart := 0;			IntegerPart := 0;			neg:=pos('-',WholeNumber);			if neg=0 then				neg:=1			else				begin					Delete(WholeNumber, 1, Neg);					neg:=-1;				end;			DecimalPos := pos('.', WholeNumber);			if DecimalPos = 0 then				stringtonum(WholeNumber, IntegerPart)			else				begin					if DecimalPos <> 1 then						StringToNum(copy(WholeNumber, 1, DecimalPos - 1), integerpart);					Zeros := 0;					Delete(WholeNumber, 1, DecimalPos);					while copy(WholeNumber, 1, 1) = '0' do						begin							Delete(WholeNumber, 1, 1);							Zeros := Zeros + 1;						end;					wholeNumber := copy(WholeNumber, 1, DecAcc);					StringToNum(WholeNumber, DecimalPart);				end;			TheReal := neg*(IntegerPart + (DecimalPart / Power10(zeros + Length(WholeNumber))));		end;{*************************}	procedure MyListDef(		lMessage :			 Integer;		lSelect :			 Boolean;		lRect :			Rect;		lCell :			Cell;		lDataOffSet :			Integer;		lDataLen :			Integer;		lHandle :			ListHandle);		procedure DoDrawMsg(SelectIt : boolean;				theRect : Rect;				theCell : Cell;				theHandle : ListHandle);			var				Particle:ParticleType;				thestring:str255;				len:Integer;				TempRect:Rect;			begin				TempRect:=TheRect;				EraseRect(TempRect);				InsetRect(TempRect,1,1);				frameRect(TempRect);				len:=SizeOf(Particle);				LGetCell(pointer(ord(@Particle)),Len,TheCell,List);				if len = SizeOf(Particle) then					begin						RealToString(Particle.Xsec,TheString);						MoveTo(theRect.left + 18, theRect.bottom - 4);						DrawString(theString);					end;				if SelectIt then					invertRect(theRect);			end;		begin			case lMessage of				lInitMsg:;				lDrawMsg:DoDrawMsg(lSelect,lRect,lCell,lHandle);				lHiliteMsg:invertRect(lRect);				lCloseMsg:;			end;		end;{*************************}	procedure CleanParticle(var Particle:ParticleType);		begin			with Particle do				begin					number:=' ';					xsec:=0; 					ysec:=0; 					zsec:=0; 					GrainCount:=0; 					P:=0; 					L:=0; 					Fate:=' ';					beta:=0;					pseudo:=0;					azimuth:=0;					degrees:=0;					azidegree:=0;					deltax:=0;					deltay:=0;					deltaz:=0; 					bigx:=0; 					bigz:=0; 					deltar:=0; 					XStar:=0;					YStar:=0; 					ZStar:=0;				end;		end;     procedure AddParticle(var	Particle				:ParticleType);		var			Last:Cell;			Dummy:Integer;			aBol:Boolean;		begin			last.h:=0;			last.v:=0;			if LGetSelect(true,last,list) then				LSetSelect(False,Last,list);			Dummy:=LAddRow(1,Header.NumParticle+1,List);			Last.h:=0;			Last.v:=Header.NumParticle;			LSetCell(pointer(ord(@Particle)),SizeOf(Particle),Last,List);			LSetSelect(true,Last,List);			Header.NumParticle:=Header.NumParticle+1;		end;     procedure DeleteParticle(var NoSelect:Boolean);		var			last:Cell;		begin			NoSelect:=False;			if LGetSelect(true,Last,List) then				begin					LDelRow(1,Last.v,List);					Header.NumParticle:=Header.NumParticle-1;				end			else				NoSelect:=True;		end;     procedure GetParticle(	var Particle:ParticleType;     											var NoSelect:Boolean);		var			Last:Cell;			len:Integer;		begin			NoSelect:=False;			last.h:=0;			last.v:=0;			if LGetSelect(true,last,list) then				begin					len:=SizeOf(Particle);					LGetCell(pointer(ord(@Particle)),Len,Last,List);				end			else				NoSelect:=true;		end;	 procedure GetLastParticle(	var Particle:ParticleType;     											var NoSelect:Boolean);		var			Last:Cell;			len:Integer;		begin			NoSelect:=False;			last.v:=0;			if Header.NumParticle>0 then				begin					Last.h :=Header.NumParticle-1;					len:=SizeOf(Particle);					LGetCell(pointer(ord(@Particle)),Len,Last,List);				end			else				NoSelect:=true;		end;     procedure SetParticle(	var Particle:ParticleType;     										var NoSelect:Boolean);		var			Last:Cell;		begin			NoSelect:=False;			last.h:=0;			last.v:=0;			if LGetSelect(true,last,list) then				LSetCell(pointer(ord(@Particle)),SizeOf(Particle),Last,List)			else				NoSelect:=true;		end;{******************************}	procedure CleanHeader;		var			i:integer;		begin			with Header do				begin				    Beam:='';					Event:=''; 					Date:=''; 					plate:=''; 					part:=''; 					operator:=''; 					rangetostar:=''; 					ZZO:=0; 					ShrinkFactZT:=0; 					ShrinkFactZM:=0; 					Magnification:=0; 					for i:=1 to 4 do 						begin 							X[i]:=0.0; 							y[i]:=0.0; 							z[i]:=0.0; 						end;					dipofprimary:=0; 					ShrinkFactAN:=0; 					primary:=''; 					frag:=''; 					a:=''; 					p:=''; 					M:=''; 					NH:=''; 					FBL:=''; 					G1:=''; 					BBL:=''; 					G2:='';				end;		end;{*****************************}	Procedure SetDlgStr(	Item				:integer;										TheString		:str255);		var			ItemType		:integer;			TextHandle		:Handle;			Box					:rect;		begin			GetDItem(DialogPointer,Item,ItemType,TextHandle,Box);			SetItext(TextHandle,TheString);		end;	procedure SetReal(	Item					:integer;										TheReal				:real);		var			ItemType		:integer;			TextHandle		:Handle;			Box					:rect;			TheString		:str255;		begin			GetDItem(DialogPointer,item,ItemType,TextHandle,Box);			RealToString(TheReal,TheString);			SetItext(TextHandle,TheString);		end;	function GetDlgStr(	Item				:integer):str255;		var			ItemType		:integer;			TextHandle		:Handle;			Box					:rect;			TheString		:str255;		begin			GetDItem(DialogPointer,Item,ItemType,TextHandle,Box);			GetItext(TextHandle,TheString);			GetDlgStr:=TheString;		end;	function GetReal(	Item					:integer):Real;		var			ItemType		:integer;			TextHandle		:Handle;			Box					:rect;			RealString		:str255;			TheReal			:real;		begin			GetDItem(DialogPointer,item,ItemType,TextHandle,Box);			GetItext(TextHandle,RealString);			StringToReal(RealString,TheReal);			GetReal:=TheReal;		end;{********************}	procedure ClearBuffer(var FootStop:Boolean);		var			ch:char;			Dummy:Longint;		begin			Delay(15,dummy);			FootStop:=False;			While InReady(SPortA) do				begin					GetChar(SPortA,ch);					if  ch = 'S' then						FootStop:=True;				end;		end;	procedure GetStringM(var TheString:str255);		var			ch:char;			i:integer;			A:integer;		begin			thestring:='';			repeat				begin					GetChar(SPortA,ch);					if  ch > chr(32) then						thestring:=concat(thestring,ch);				end;			until ch=chr(10);		end;	procedure SendString(TheString:str255);		var			i:integer;		begin			for i := 1 to Length(TheString) do				sendChar(SPortA,TheString[i]);			sendChar(SPortA,chr(13));			sendChar(SPortA,chr(10));		end;	procedure ReadMicro(var channel1,channel2,channel3:Real;						var	FootStop:Boolean);		var			TheString:str255;			Dummy:boolean;		begin			ClearBuffer(FootStop);			SendString('D1');			getStringM(TheString);			StringtoReal(TheString,channel1);			SendString('D2');			getStringM(TheString);			StringtoReal(TheString,channel2);			SendString('D3');			getStringM(TheString);			StringtoReal(TheString,channel3);			ClearBuffer(dummy);		end;{***********************}	Function Filter(TheDialog:DialogPtr;		var theEvent:EventRecord;		var itemNumber:Integer):			Boolean;		const			returnCode=				13;			enterCode=				3;			CancelCode=				27;		var			charCode:				char;		begin			Filter:=false;			if theEvent.What = keyDown then				begin					CharCode:=chr(BitAnd(theEvent.message,charCodeMask));					if BitAnd(theEvent.modifiers,CmdKey) = CmdKey then						begin							case CharCode of								'X':DlgCut(TheDialog);								'C':DlgCopy(TheDialog);								'V':DlgPaste(TheDialog);								'B':DlgDelete(TheDialog);							end;							Filter:=true;						end;					if CharCode = chr(returnCode) then						begin							itemNumber:=OK;							Filter:=true;						end;					if CharCode = chr(CancelCode) then						begin							itemNumber := Cancel;							Filter:=true;						end;					if CharCode = chr(enterCode) then						begin							theEvent.message:=theEvent.message+6;							Filter:=false;						end;				end;			if inReady(SPortA) then				begin					itemNumber:=99;					Filter:=True;				end;		end;{*********************}	procedure GetHeaderDialog;		var			i:integer;				begin		    Header.Beam:=GetDlgStr(8);		    Header.Date:=GetDlgStr(9);			Header.Event:=GetDlgStr(10);			Header.Operator:=GetDlgStr(11);			Header.Plate:=GetDlgStr(12);			Header.Part:=GetDlgStr(13);			Header.Rangetostar:=GetDlgStr(14);							Header.ShrinkFactZT:=GetReal(15);			Header.ShrinkFactZM:=GetReal(16);			Header.Magnification:=GetReal(17);			Header.ZZO:=GetReal(18);			Header.Primary:=GetDlgStr(19);			Header.Frag:=GetDlgStr(20);			Header.a:=GetDlgStr(21);			Header.p:=GetDlgStr(22);			Header.M:=GetDlgStr(23);			Header.NH:=GetDlgStr(24);			Header.FBL:=GetDlgStr(25);			Header.G1:=GetDlgStr(26);			Header.BBL:=GetDlgStr(27);			Header.G2:=GetDlgStr(28);			for i:=1 to 4 do				begin					Header.X[i]:=GetReal(29+(i-1)*3);					Header.Y[i]:=GetReal(30+(i-1)*3);					Header.Z[i]:=GetReal(31+(i-1)*3);				end;		end;	procedure SetHeaderDialog;		var			i:integer;					begin		    SetDlgStr(8,Header.Beam);			SetDlgStr(9,Header.Date);			SetDlgStr(10,Header.Event);       	SetDlgStr(11,Header.Operator);			SetDlgStr(12,Header.Plate);			SetDlgStr(13,Header.Part);			SetDlgStr(14,Header.Rangetostar);			SetReal(15,Header.ShrinkFactZT);			SetReal(16,Header.ShrinkFactZM);			SetReal(17,Header.Magnification);			SetReal(18,Header.ZZO);			SetDlgStr(19,Header.Primary);			SetDlgStr(20,Header.Frag);			SetDlgStr(21,Header.a);			SetDlgStr(22,Header.p);			SetDlgStr(23,Header.M);			SetDlgStr(24,Header.NH);			SetDlgStr(25,Header.FBL);			SetDlgStr(26,Header.G1);			SetDlgStr(27,Header.BBL);			SetDlgStr(28,Header.G2);			for i:=1 to 4 do				begin					SetReal(29+(i-1)*3,Header.X[i]);					SetReal(30+(i-1)*3,Header.Y[i]);					SetReal(31+(i-1)*3,Header.Z[i]);				end;			SetReal(41,Header.SlopeXY);			SetReal(42,Header.SlopeZY);			SetReal(43,Header.ShrinkFactAN);		end;	Procedure HeaderDefault;		var			seconds:longint;					begin			if Header.Date = '' then				begin					getdatetime(seconds);					IUDateString(seconds,shortDate,Header.Date);				end;		end;	procedure SetParticleDialog(var Particle:ParticleType);		begin			SetDlgStr(6,Particle.Number);			SetReal(7,Particle.xstar);			SetReal(8,Particle.ystar);			SetReal(9,Particle.zstar);			SetReal(10,Particle.xsec);			SetReal(11,Particle.ysec);			SetReal(12,Particle.zsec);			SetReal(13,Particle.pseudo);			SetReal(14,Particle.BigX);			SetReal(15,Particle.BigZ);			SetReal(16,Particle.deltaX);			SetReal(17,Particle.deltaY);			SetReal(18,Particle.deltaZ);			SetReal(19,Particle.deltaR);			SetReal(20,Particle.Beta);			SetReal(21,Particle.degrees);			SetReal(22,Particle.azimuth);			SetReal(23,Particle.azidegree);		end;	procedure GetParticleDialog(var Particle:ParticleType);		begin			Particle.Number:=GetDlgStr(6);			Particle.xstar:=GetReal(7);			Particle.ystar:=GetReal(8);			Particle.zstar:=GetReal(9);			Particle.xsec:=GetReal(10);			Particle.ysec:=GetReal(11);			Particle.zsec:=GetReal(12);		end;	procedure DefaultParticle(var Particle:ParticleType);		var			LastParticle:ParticleType;			NoSelect:Boolean;					begin			if Header.NumParticle > 0 then 				begin					GetLastParticle(LastParticle,NoSelect);					Particle.Xstar:=LastParticle.Xstar;					Particle.Ystar:=LastParticle.Ystar;					Particle.Zstar:=LastParticle.Zstar;				end;		end;	procedure NullButton(			ItemHit				:integer;		var			Done,			Cancel				:Boolean);		begin			case itemHit of				1:	Done:=true;				2:	begin							done:=true;                      		cancel:=true;                    	end;			end;		end;	procedure HeaderButton(			ItemHit				:integer;		var			Done,			Cancel				:Boolean);		begin			case itemHit of				1:	Done:=true;				2:	begin							done:=true;                      		cancel:=true;                    	end;				3:	begin							GetHeaderDialog;							CalcHeader;							SetHeaderDialog;						end;			end;		end;	procedure ParticleButton(			ItemHit				:integer;		var			Done,			Cancel				:Boolean);		var			DumbParticle:				ParticleType;			channel1,			channel2,			channel3:				Real;			footstop:				Boolean;		begin 			case itemHit of				1:	Done:=true;				2:	begin							done:=true;                      		cancel:=true;                    	end;				3:	begin							GetParticleDialog(DumbParticle);							CalcParticle(DumbParticle,Header);							SetParticleDialog(DumbParticle);						end;				99:	begin                    		ReadMicro(channel1,channel2,channel3,FootStop);							if FootStop then								done:=true;							SetReal(4,channel1);							SetReal(5,channel2);							SetReal(6,channel3);							ClearBuffer(FootStop);						end;			end;		end;	Procedure Modal(		var			cancel:				Boolean;			button:				Integer);		Var			itemHit:				integer;			Done:				boolean;  		begin  			cancel:=false;  			done:=false;        	repeat            	begin {repeat}               	ModalDialog(@Filter,itemHit);               	case Button of               		1:	NullButton(ItemHit,Done,Cancel);               		2:	ParticleButton(ItemHit,Done,Cancel);               		3:	HeaderButton(ItemHit,Done,Cancel);               	end;              	end;{repeat}          	until done;    	end;{dialog}    procedure HeaderDialog(var cancel:boolean);			begin			DialogPointer:=GetNewDialog(HeaderLTRes,nil,pointer(-1));			SetHeaderDialog;			Modal(Cancel,3);			if not cancel then				begin					GetHeaderDialog;					CalcHeader;				end;			CloseDialog(DialogPointer);		end;		    procedure ParticleDialog(	var Particle		:ParticleType;    										var Cancel		:Boolean);		begin			DialogPointer:=GetNewDialog(ParticleLTRes,nil,pointer(-1));			SetParticleDialog(Particle);			Modal(Cancel,2);			if not cancel then				begin					GetParticleDialog(Particle);					CalcParticle(particle,header);				end;			CloseDialog(DialogPointer);		end;		{*******************}	procedure DebugDialog{(	theString:str255;    											theReal:Real;    											TheInteger:integer)};		var			cancel:boolean;    	begin    		DialogPointer:=GetNewDialog(DebugRes,nil,pointer(-1));    		SetDlgStr(3,TheString);			SetReal(4,TheReal);			NumToString(TheInteger,TheString);			SetDlgStr(5,TheString);    		Modal(Cancel,1);			CloseDialog(DialogPointer);    	end;	procedure AreYouSure(	TheString	:Str255;											var cancel	:boolean);		begin			DialogPointer:=GetNewDialog(AreSureRes,nil,pointer(-1));			SetDlgStr(3,TheString);			Modal(Cancel,1);			CloseDialog(DialogPointer);		end;{**********************}	procedure ProcessMenu(CodeWord : LongInt);		var			menuNum : Integer;			itemNum : Integer;{***********************}		procedure DoAppleMenu;			procedure About;				var					AboutRecord : DialogRecord;					AboutDlog : DialogPtr;					dummy:integer;				begin					AboutDlog := GetNewDialog(AboutRes,nil,Pointer(-1));					ModalDialog(nil,dummy);					CloseDialog(AboutDlog);				end;			procedure DeskAccesory;				var					dummy:integer;					nameHolder : str255;				begin					GetItem(myMenus[appleMenu],ItemNum,NameHolder);					dummy := OpenDeskAcc(NameHolder);				end;			begin				case ItemNum of					1:About;					2 :;					otherwise						deskAccesory;				end;			end;{*****************}		procedure DoEditMenu;			begin				if not SystemEdit(ItemNum - 1) then					begin						case ItemNum of						end;					end;			end;{*****************}		procedure DoFileMenu;			{procedures for file menu}			procedure NewList;				var					CSize:Point;					DataBounds,rview:Rect;				begin					if InMem then						begin							LDispose(List);							CloseWindow(listWindow);						end;					ListWindow:=GetNewWindow(300,nil,Pointer(-1));					SetPort(ListWindow);					Databounds.top:=0;					DataBounds.Left:=0;					DataBounds.Bottom:=0;					DataBounds.Right:=1;					Rview:=ListWindow^.PortRect;					Rview.right:=Rview.right-16;					CSize.v:=16;					CSize.h:=rview.right-rview.left;					list:=Lnew(Rview,databounds,cSize,0,Listwindow,false,false,false,true);					List^^.ListDefProc:=NewHandle(0);					List^^.ListDefProc^:=ptr(@MyListDef);					List^^.selFlags:=lOnlyOne;					LDoDraw(true,List);				end;			procedure FileError;				var					TheError:str255;					  				begin  					if IOR > 0 then  						begin  							GetErrorMessage(IOR,TheError);  							DebugDialog(TheError,IOR,0);  						end;  				end;			procedure ReadFile(Reply:SFReply);				var					f:filerec;					i:integer;					Particle:ParticleType;					Temp:Integer;				begin					FReset(f,reply.vRefNum,reply.fName);					FGetM(f,@Header,SizeOf(Header));					Header.Reply:=Reply;					Temp:=Header.NumParticle;					newlist;					Header.NumParticle:=0;					SetWTitle(ListWindow,Header.reply.fName);					for i := 1 to Temp do						begin							FGetM(f,@Particle,SizeOf(Particle));							AddParticle(Particle);						end;					FClose(f);					FileError;				end;			procedure WriteFile(Reply:SFReply);				var					f:FileRec;					Particle:ParticleType;					len:integer;					Last:Cell;					I:integer;				begin					FRewrite(f,reply.vRefNum,reply.fName,'DATA','MICR');					FPutM(f,@Header,SizeOf(Header));					len:=SizeOf(Particle);					last.h:=0;					SetWTitle(ListWindow,Header.reply.fName);					for i := 1 to Header.NumParticle do						begin							Last.v:=i-1;							LGetCell(pointer(ord(@Particle)),Len,Last,List);							FPutM(f,@Particle,SizeOf(Particle));						end;					FClose(f);					FileError;				end;			procedure GetReadFile(var reply:SFReply);				var					pt:point;					FileType:SFTypeList;				begin					pt.h:=50;					pt.v:=50;					FileType[0][1]:='D';					FileType[0][2]:='A';					FileType[0][3]:='T';					FileType[0][4]:='A';					SFGetFile(pt,'Enter File',nil,1,filetype,nil,reply);				end;			procedure GetWriteFile(var reply:SFReply);				var					pt:point;				begin					pt.h:=50;					pt.v:=50;					SFPutFile(pt,'Save File',Reply.Fname,nil,reply);				end;			{the File menu procedures}			procedure NewFile;				var					cancel:boolean;				begin					if changed and InMem then						AreYouSure('Are you sure you want to throw away Changes to this file?',Cancel);					if not cancel then						begin							CleanHeader;							HeaderDefault;							HeaderDialog(Cancel);							NewList;							Header.Reply.FName:='untitled';							SetWTitle(ListWindow,Header.reply.fName);							Header.NumParticle:=0;							changed:=True;							InMem:=True;							FromFile:=False;						end;				end;			procedure OpenFile;				var					Cancel:Boolean;				begin					if inmem and Changed then						AreYouSure('Are you sure you want to throw away Changes to this file?',Cancel);					if not cancel then						begin							GetReadFile(Header.Reply);							if  Header.Reply.good then								begin									ReadFile(Header.Reply);									Changed:=True;									InMem:=True;									fromFile:=true;								end;						end;				end;			Procedure CloseFile;				var					cancel:Boolean;				begin					if Changed and inmem then						AreYouSure('Are you sure you want to throw away Changes to this file?',Cancel);					if not cancel then						begin							LDispose(List);							DisposeWindow(listWindow);							InMem:=False;							changed:=False;							FromFile:=False;						end;				end;			Procedure SaveAsFile;				begin					GetWriteFile(Header.Reply);					if Header.Reply.Good then						begin							WriteFile(Header.Reply);							Changed:=False;							FromFile:=true;						end;				end;			Procedure SaveFile;				begin					WriteFile(Header.Reply);					Changed:=False;					FromFile:=true;				end;			Procedure RevertFile;				var					cancel:Boolean;				begin					if Changed and inmem then						AreYouSure('Are you sure you want to throw away Changes to this file?',Cancel);					if not cancel then						begin							NewList;							ReadFile(Header.Reply);							Changed:=False;							InMem:=True;							fromFile:=true;						end;				end;			Procedure AppendFile;				Var					Reply:SFReply;					F:Text;					Last:Cell;					Particle:ParticleType;					i:integer;					len:integer;				Const					Wide=10;									begin					GetWriteFile(Reply);					Open(F,Reply.FName);					Rewrite(F);					with Header Do						begin							writeln(F,NumParticle:Wide); 							writeln(F,slopexy:Wide:DecAcc); 							writeln(F,slopezy:Wide:DecAcc); 							writeln(F,Event:Wide); 							writeln(F,Date:Wide); 							writeln(F,operator:Wide); 							writeln(F,ShrinkFactZT:Wide:DecAcc); 							writeln(F,ShrinkFactZM:Wide:DecAcc); 							writeln(F,Magnification:Wide:DecAcc); 							writeln(F,ZZO:Wide:DecAcc); 							writeln(F,X[1]:Wide:DecAcc,chr(9),Y[1]:Wide:DecAcc,chr(9),Z[1]:Wide:DecAcc); 							writeln(F,X[2]:Wide:DecAcc,chr(9),Y[2]:Wide:DecAcc,chr(9),Z[2]:Wide:DecAcc); 							writeln(F,X[3]:Wide:DecAcc,chr(9),Y[3]:Wide:DecAcc,chr(9),Z[3]:Wide:DecAcc); 							writeln(F,X[4]:Wide:DecAcc,chr(9),Y[4]:Wide:DecAcc,chr(9),Z[4]:Wide:DecAcc); 							writeln(F,Beam:Wide); 							writeln(F,Plate:Wide); 							writeln(F,part:Wide); 							writeln(F,Rangetostar:Wide); 							writeln(F,Primary:Wide); 							writeln(F,Frag:Wide); 							writeln(F,a:Wide); 							writeln(F,p:Wide); 							writeln(F,M:Wide); 							writeln(F,NH:Wide); 							writeln(F,FBL:Wide); 							writeln(F,G1:Wide); 							writeln(F,BBL:Wide); 							writeln(F,G2:Wide); 							writeln(F,ShrinkFactAN:Wide:DecAcc); 							writeln(F,dipofprimary:Wide:DecAcc); 							Writeln(F); 						end;					last.h:=0;					len:=SizeOf(Particle);					for i := 1 to Header.NumParticle do						begin							Last.v:=i-1;							LGetCell(pointer(ord(@Particle)),Len,Last,List);							with particle do								begin									write(F,Number:Wide,Chr(9)); 									write(F,xsec:Wide:DecAcc,Chr(9)); 									write(F,ysec:Wide:DecAcc,Chr(9)); 									write(F,zsec:Wide:DecAcc,Chr(9)); 									write(F,GrainCount:Wide:DecAcc,Chr(9)); 									write(F,P:Wide:DecAcc,Chr(9)); 									write(F,L:Wide:DecAcc,Chr(9)); 									write(F,Fate:Wide,Chr(9));									write(F,beta:Wide:DecAcc,Chr(9));									write(F,degrees:Wide:DecAcc,Chr(9));									write(F,azimuth:Wide:DecAcc,Chr(9));									write(F,azidegree:Wide:DecAcc,Chr(9));									write(F,pseudo:Wide:DecAcc,Chr(9));									write(F,deltax:Wide:DecAcc,Chr(9));									write(F,deltay:Wide:DecAcc,Chr(9));									write(F,deltaz:Wide:DecAcc,Chr(9));									write(F,bigx:Wide:DecAcc,Chr(9));									write(F,bigz:Wide:DecAcc,Chr(9));									write(F,deltar:Wide:DecAcc,Chr(9));									write(F,xstar:Wide:DecAcc,Chr(9));									write(F,ystar:Wide:DecAcc,Chr(9));									writeln(F,zstar:Wide:DecAcc);								end;						end;					Close(F);				end;			Procedure PageSetUp;				var					trueORfalse : boolean;				begin  					trueORfalse := PrValidate(PgSetUp);					trueORfalse := PrStlDialog(PgSetUp);				end;			Procedure PrintFile;				var					PrintPort:TPPrPort;				begin				end;			Procedure QuitProgram;							var					cancel:Boolean;				begin					if Changed and inmem then						AreYouSure('Are you sure you want to throw away Changes to this file?',Cancel);					if not cancel then						Done:=True;				end;			begin				case ItemNum of					1:NewFile;					2:OpenFile;					3:CloseFile;					4:;					5:SaveFile;					6:SaveAsFile;					7:RevertFile;					8:;					9:AppendFile;					10:;					11:PageSetUp;					12:PrintFile;					13:;					14:QuitProgram;				end;				DrawMenu;			end;{******************}		procedure DoParticleMenu;			procedure NewParticle(var Cancel:Boolean);				var					particle:ParticleType;				begin					CleanParticle(Particle);					DefaultParticle(Particle);					ParticleDialog(Particle,cancel);					if not cancel then						begin							AddParticle(Particle);							Changed:=true;						end;				end;			procedure AddParticleMenu;				var					cancel:boolean;				begin					NewParticle(Cancel);				end;			procedure AddContinuousParticle;				var					cancel:boolean;				begin					repeat						NewParticle(Cancel);					until cancel;				end;			procedure EditParticle;				var					cancel,NoSelect:boolean;					Particle:ParticleType;				begin					GetParticle(Particle,NoSelect);					if not NoSelect then						begin							ParticleDialog(Particle,cancel);							if not cancel then								begin									SetParticle(Particle,NoSelect);									Changed:=true;								end;						end;				end;			procedure ClearParticle;				var					particle:ParticleType;					NoSelect:Boolean;				begin					GetParticle(Particle,NoSelect);					if not NoSelect then						begin							CleanParticle(Particle);							SetParticle(Particle,NoSelect);							Changed:=true;						end;				end;			procedure DeleteParticleMenu;				var					noSelect:Boolean;				begin					DeleteParticle(NoSelect);					if Not NoSelect then						changed:=true;				end;			begin				case ItemNum of					1:AddParticleMenu;					2:AddContinuousParticle;					3:EditParticle;					4:ClearParticle;					5:DeleteParticleMenu;				end;				DrawMenu;			end;{****************}		procedure DoHeaderMenu;			procedure EditHeader;				var					cancel:boolean;				begin					HeaderDialog(Cancel);					if not cancel then						Changed:=true;				end;			Procedure ClearHeader;				begin					CleanHeader;					changed:=true;				end;			begin				case ItemNum of					1:EditHeader;					2:ClearHeader;				end;				DrawMenu;			end;{*****************}		begin			menuNum := HiWord(CodeWord);			itemNum := LoWord(CodeWord);			if itemNum > 0 then				begin					case MenuNum of						1:DoAppleMenu;						2:DoFileMenu;						3:DoEditMenu;						4:DoParticleMenu;						5:DoHeaderMenu;					end;				end;			HiliteMenu(0);		end;{******************}	procedure AllDone;		begin			CloseSPort(sPortA);		end;{******************}	procedure MainEventLoop;		var			Event : EventRecord;			windowLoc : integer;			mouseLoc : point;			theWindow:WindowPtr;			CharCode : Char;			DummyBoolean : Boolean;			Last:Cell;		begin			repeat				SystemTask;				if InMem then					begin						Last.v:=0;						Last.h:=0;						if not LGetSelect(true,Last,List) then							begin								Last.v:=0;								Last.h:=0;								LSetSelect(True,last,List);							end;					end;				if GetNextEvent(everyEvent,Event) then					begin						case event.what of							mouseDown :								begin									mouseLoc := Event.where;									windowLoc := FindWindow(mouseLoc,theWindow);									case windowLoc of										inMenuBar :											ProcessMenu(MenuSelect(MouseLoc));										inSysWindow:											SystemClick(Event,theWindow);										inContent:											begin												GlobalToLocal(MouseLoc);												DummyBoolean := LClick(MouseLoc, Event.modifiers,List);											end;										inDrag:											begin        										DragWindow(theWindow,mouseLoc,DragArea);												SelectWindow(theWindow);      										end;      									inGrow:      										begin      											GlobalToLocal(MouseLoc);												DummyBoolean := LClick(MouseLoc, Event.modifiers,List);      										end;      									inGoAway:      										begin      										end;      									inDesk:      										Begin      										end;									end;								end;							UpdateEvt :								begin									BeginUpdate(ListWindow);									List^^.listdefProc^ := Ptr(@MyListDef);									LUpdate(ListWindow^.visRgn,List);									EndUpdate(ListWindow);								end;							ActivateEvt :								begin									LActivate(Odd(Event.modifiers),List);									InvalRect(ListWindow^.PortRect);								end;							keyDown,AutoKey :								begin									CharCode := chr(BitAnd(Event.message,charCodeMask));;									if BitAnd(Event.modifiers,CmdKey) = CmdKey then										ProcessMenu(MenuKey(CharCode));								end;						end;					end;			until Done;		end;{**************************}	procedure InitThings;		procedure SetupLimits;			var				Screen : Rect;			begin				Screen := ScreenBits.bounds;				with Screen do					begin						SetRect(DragArea,left+4,top+24,right-4,bottom-4);						SetRect(GrowArea,left,top+24,right,bottom);					end;			end;		procedure SetUpMenus;				var					index : integer;			begin				for index := beginMenu to endMenu do					myMenus[index] := GetMenu(index);				AddResMenu(myMenus[appleMenu],'DRVR');				for index := beginMenu to endMenu do					InsertMenu(myMenus[index],0);				DrawMenu;			end;		procedure SetUpPort;			var				Dummy:integer;			begin				Dummy:=InitSPort(SPortA,baud2400,stop10,noParity,data7,1000,xOnXOff,xOnXOff);				SendString('SON');				SetBufSize(1000);			end;		procedure SetupMemory;			var				x : Longint;			begin				x := ORD4(ApplicZone) + 256000;				SetApplLimit(Pointer(x));				MaxApplZone;				MoreMasters;				MoreMasters;				MoreMasters;				MoreMasters;				MoreMasters;				MoreMasters;			end;		begin			Done:=False;			InMem:=False;			Changed:=False;			FromFile:=False;			FlushEvents(everyEvent,0);			InitGraf(@thePort);			InitFonts;			InitWindows;			InitMenus;			TEInit;			InitDialogs(nil);			InitCursor;			InitAllPacks;			SetupLimits;			SetUpMemory;			SetUpMenus;			SetUpPort;		end;{***********************}	begin		initThings;		MainEventLoop;		AllDone;	end.