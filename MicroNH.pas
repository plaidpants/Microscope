 program Micro;  	{$B+}  	{$T APPL MICR}	{$L MicroRsrc}	{$I TML:Library:MemTypes.ipas}	{$I TML:Library:QuickDraw.ipas}	{$I TML:Library:OSIntf.ipas}	{$I TML:Library:ToolIntf.ipas}	{$I TML:Library:PackIntf.ipas}	{$I TML:Library:ListMgrIntf.ipas}	{$I TML:Library:MacPrint.ipas}	{$I TML:Library:FileIo.iPas}	{$I TML:Library:Serial.iPas}	type		{My Types}		arr4=array[1..4] of real; 		HeaderType= 			packed record 				Reply:SfReply; 				NumParticle:Integer; 				Event:str255; 				Date:str255; 				operator:str255; 				ShrinkFactZT:Real; 				ShrinkFactZM:Real; 				Magnification:Real; 				ZZO:Real; 				X:arr4; 				y:arr4; 				z:arr4; 				ShrinkFactAN:Real; 				dipofprimary:real; 			end; 		ParticleType= 			packed record 				Number:Str255; 				theta:real; 				ZScaleDiv:Real; 				Ymicrons:real; 				GrainCount:real; 				P:Real; 				L:real; 				Fate:str255;				beta:real;					{beta}				degrees:real;				{beta expressed in degrees}				azimuth:real;				{azimuth angle}				azidegree:real;			{azimuth angle expressed in degress}				pseudo:real;				{pseudoripidity}				dip:real;						{slope of children particles with respect to the primary}				x:real;						{the value calculated from the raw data}				y:real;						{the value calculated from the raw data}				z:real;						{the value calculated from the raw data}			end;		TrickType =			packed record				case boolean of					true :						(I : LongInt);					false :						(chr3, chr2, chr1, chr0 : Char);				end;	const		HeaderRes=			6000;		ParticleRes=			6001;		DebugRes=			6002;		AreSureRes=			6003;		AboutRes=			6004;		appleMenu =			300;		fileMenu =			301;		editMenu =			302;		particleMenu =			303;		HeaderMenu =			304;		beginMenu =			300;		endMenu =			304;		MicroKind=			'DATA';		MicroCreator=			'MICR';		pi=			3.1415926535898;		DecAcc=			4;	var		{Mac Varibles}		Done:			Boolean;		myMenus:			 array[beginMenu..endMenu] of MenuHandle;		DragArea,		GrowArea:			Rect;		{My Global Varibles}		InMem,		FromFile,		changed:			Boolean;		PgSetUp : THPrint;		Header:			HeaderType;		List:			ListHandle;		ListWindow:			WindowPtr;		DialogPointer:			DialogPtr;	procedure DebugDialog(	theString:str255;    											theReal:Real;    											TheInteger:integer);    	forward;	procedure CalcHeader(var Header:HeaderType);		{calculates the dip of the primary}		var			n:integer;			{the # of points at which the primary was measured}			j:integer;			{j will be the array indice counter throughout}			partialdip:real;	{partial sum of dip}		begin {primary}			partialdip:=0;			{at how many points was the primary measured};			{send in each x,y,z cooridinate}			if (header.x[4]=0) and (header.y[4]=0) and (header.z[4]=0) then				n:=3			else n:=4;				for j:=n downto 2 do					partialdip:= ((header.z[j]-header.z[j-1])/(header.y[j]-header.y[j-1]))+partialdip;			if Header.ShrinkFactZM<>0 then				Header.ShrinkFactAN:=Header.ShrinkFactZT/Header.ShrinkFactZM;			header.dipofprimary:= (partialdip/((n-1)*1000))*(header.shrinkFactAN);		end;{primary}	procedure CalcParticle(var Particle:ParticleType;													Header:HeaderType);		{michael heinrich}		{5/28/86}		{this program will take raw data recorded by}		{workers using optical microscopes for cosmic ray research}		{the raw data is converted into x,y,z coordinates }		procedure particleStuff;			{inputs the data for the individual particles}			{in the star and calculates their dips}			begin {particle}				with Particle do					dip:=(ZScalediv)/(ymicrons);			end;{particle}		procedure calculate;			{calculates x,y,z}			{x,y,z are 1 dimensional arrays used by research}			begin {calculate}				Particle.x:=(Particle.ymicrons)*sin((Particle.theta)*(pi/180));				Particle.y:=(Particle.ymicrons)*cos((Particle.theta)*(pi/180));				if abs(Particle.theta)<=90 then					Particle.z:=(Particle.dip-header.dipofprimary)*(Particle.ymicrons)*(header.ShrinkFactAN)				else					Particle.z:=(Particle.dip+header.dipofprimary)*(Particle.ymicrons)*(header.ShrinkFactAN);			end;{calculate}		procedure research1;   		{written by michael heinrich}   		{5/8/86}   		{this program will take data from a data file }   		{which specifies x,y,z coordinates and calculate}   		{beta,pseudoripidity,and azimuth angle}       	{this procedure reads and manipulates one }       	{line of data from the dataout}			var				j:integer;			procedure calcbeta;			{calculates beta}				begin {beta}					Particle.beta:=arctan(sqrt(sqr(Particle.x)+sqr(Particle.z))/abs(Particle.y));					if abs(Particle.y)<>Particle.y then						Particle.beta:=-Particle.beta;					if Particle.y<0 then						Particle.beta:=Particle.beta+pi;					Particle.degrees:=Particle.beta*180/pi				end;{beta}			procedure psuedoripidity;				{calculates pseudoripidity}				begin {psuedoripidity}					Particle.pseudo:=-ln(abs(sin(Particle.beta/2)/cos(Particle.beta/2)));				end;{psuedoripidity}			procedure azimuthangle;				{calculates azimuth angle}				begin {azimuthangle}					if Particle.z=0 then						Particle.azimuth:=(pi/2)					else						begin         {z<>0}							Particle.azimuth:=arctan(abs(Particle.x/Particle.z));							{computer won't take - values in function}							if abs(Particle.x/Particle.z)<>(Particle.x/Particle.z) then								Particle.azimuth:=-Particle.azimuth;							{corrected for - values}						end;					{now implement Dr. Frier's sign convention}					if Particle.z < 0 then							{z < 0}							Particle.azimuth:=Particle.azimuth+pi					else    {z >= 0}						begin							if Particle.x<0 then								{z >= 0 and x < 0}								Particle.azimuth:=Particle.azimuth+2*pi;						end;					Particle.azidegree:=Particle.azimuth*180/pi;			end;{azimuthangle}			begin {research}				calcbeta;				psuedoripidity;				azimuthangle;			end;{research}		begin {NHmethod}			particleStuff;			calculate;			research1;		end;  {************************}  	procedure NoFileMenu;  		begin  			Enableitem(MyMenus[appleMenu],0);  			Enableitem(MyMenus[appleMenu],1);  			Enableitem(MyMenus[fileMenu],0);  			Enableitem(MyMenus[fileMenu],1);  			Enableitem(MyMenus[fileMenu],2);  			DisableItem(MyMenus[fileMenu],3);			DisableItem(MyMenus[fileMenu],5);			DisableItem(MyMenus[fileMenu],6);			DisableItem(MyMenus[fileMenu],7);			DisableItem(MyMenus[fileMenu],9);			EnableItem(MyMenus[fileMenu],11);			DisableItem(MyMenus[fileMenu],12);			EnableItem(MyMenus[fileMenu],14);			DisableItem(MyMenus[ParticleMenu],0);			DisableItem(MyMenus[HeaderMenu],0);  		end;  	procedure NewMenuNone;  		begin  			NoFileMenu;  			EnableItem(MyMenus[FileMenu],3);			EnableItem(MyMenus[FileMenu],6);			EnableItem(MyMenus[FileMenu],12);			EnableItem(MyMenus[ParticleMenu],0);			EnableItem(MyMenus[ParticleMenu],1);			EnableItem(MyMenus[ParticleMenu],2);			DisableItem(MyMenus[Particlemenu],3);			DisableItem(MyMenus[ParticleMenu],4);			DisableItem(MyMenus[ParticleMenu],5);			Enableitem(MyMenus[HeaderMenu],0);			Enableitem(MyMenus[HeaderMenu],1);			Enableitem(MyMenus[HeaderMenu],2);  		end;  	procedure NewMenuSome;  		begin  			NewMenuNone;  			EnableItem(MyMenus[ParticleMenu],3);  			EnableItem(MyMenus[ParticleMenu],4);			EnableItem(MyMenus[ParticleMenu],5);  		end;  	procedure OldMenuNone;  		begin			NewMenuNone;			EnableItem(MyMenus[FileMenu],5);			EnableItem(MyMenus[FileMenu],7);  		end;  	procedure OldMenuSome;  		begin  			OldMenuNone;  			EnableItem(MyMenus[ParticleMenu],3);  			EnableItem(MyMenus[ParticleMenu],4);			EnableItem(MyMenus[ParticleMenu],5);  		end;  	procedure DrawMenu;  		begin  			if InMem then  				if fromFile then  					if Header.NumParticle = 0 then  						OldMenuNone  					else  						OldMenuSome  				else  					if Header.NumParticle = 0 then  						NewMenuNone  					else  						NewMenuSome  			else  				NoFileMenu;  			DrawMenuBar;  		end;  {************************}	function Power10 (Expo : integer) : longint;		var			power : longint;			i : integer;		begin			power := 1;			if power <> 0 then				for i := 1 to expo do			power := Power * 10;			power10 := Power;		end;	procedure RealToString (var WholeNumber : Real;		var TheString : Str255);		var			integerPart, decimalPart : str255;		begin			numToString(trunc(abs(wholeNumber)), IntegerPart);			if wholeNumber<0 then				IntegerPart:=concat('-',IntegerPart);			numToString(round(abs(wholeNumber - trunc(wholeNumber)) * power10(DecAcc)), decimalPart);			TheSTring := concat(IntegerPart, '.', copy('000000', 1, DecAcc - length(DecimalPart)), decimalPart);		end;	procedure StringToReal (var WholeNumber : str255;		var TheReal : real);		var			decimalPos : integer;			IntegerPart : longint;			DecimalPart : longint;			zeros : integer;			neg:integer;		begin			DecimalPart := 0;			IntegerPart := 0;			neg:=pos('-',WholeNumber);			if neg=0 then				neg:=1			else				begin					Delete(WholeNumber, 1, Neg);					neg:=-1;				end;			DecimalPos := pos('.', WholeNumber);			if DecimalPos = 0 then				stringtonum(WholeNumber, IntegerPart)			else				begin					if DecimalPos <> 1 then						StringToNum(copy(WholeNumber, 1, DecimalPos - 1), integerpart);					Zeros := 0;					Delete(WholeNumber, 1, DecimalPos);					while copy(WholeNumber, 1, 1) = '0' do						begin							Delete(WholeNumber, 1, 1);							Zeros := Zeros + 1;						end;					wholeNumber := copy(WholeNumber, 1, DecAcc);					StringToNum(WholeNumber, DecimalPart);				end;			TheReal := neg*(IntegerPart + (DecimalPart / Power10(zeros + Length(WholeNumber))));		end;{*************************}	procedure MyListDef(		lMessage :			 Integer;		lSelect :			 Boolean;		lRect :			Rect;		lCell :			Cell;		lDataOffSet :			Integer;		lDataLen :			Integer;		lHandle :			ListHandle);		procedure DoDrawMsg(SelectIt : boolean;				theRect : Rect;				theCell : Cell;				theHandle : ListHandle);			var				Particle:ParticleType;				thestring:str255;				len:Integer;				TempRect:Rect;			begin				TempRect:=TheRect;				EraseRect(TempRect);				InsetRect(TempRect,1,1);				frameRect(TempRect);				len:=SizeOf(Particle);				LGetCell(pointer(ord(@Particle)),Len,TheCell,List);				if len = SizeOf(Particle) then					begin						RealToString(Particle.theta,TheString);						MoveTo(theRect.left + 18, theRect.bottom - 4);						DrawString(theString);					end;				if SelectIt then					invertRect(theRect);			end;		begin			case lMessage of				lInitMsg:;				lDrawMsg:DoDrawMsg(lSelect,lRect,lCell,lHandle);				lHiliteMsg:invertRect(lRect);				lCloseMsg:;			end;		end;{*************************}	procedure CleanParticle(var Particle:ParticleType);		begin			with Particle do				begin					number:=' ';					theta:=0; 					ZScaleDiv:=0; 					Ymicrons:=0; 					GrainCount:=0; 					P:=0; 					L:=0; 					Fate:=' ';					beta:=0;					pseudo:=0;					azimuth:=0;					degrees:=0;					azidegree:=0;					dip:=0;					x:=0;					y:=0;					z:=0;				end;		end;     procedure AddParticle(var	Particle				:ParticleType);		var			Last:Cell;			Dummy:Integer;			aBol:Boolean;		begin			last.h:=0;			last.v:=0;			if LGetSelect(true,last,list) then				LSetSelect(False,Last,list);			Dummy:=LAddRow(1,Header.NumParticle+1,List);			Last.h:=0;			Last.v:=Header.NumParticle;			LSetCell(pointer(ord(@Particle)),SizeOf(Particle),Last,List);			LSetSelect(true,Last,List);			Header.NumParticle:=Header.NumParticle+1;		end;     procedure DeleteParticle(var NoSelect:Boolean);		var			last:Cell;		begin			NoSelect:=False;			if LGetSelect(true,Last,List) then				begin					LDelRow(1,Last.v,List);					Header.NumParticle:=Header.NumParticle-1;				end			else				NoSelect:=True;		end;     procedure GetParticle(	var Particle:ParticleType;     											var NoSelect:Boolean);		var			Last:Cell;			len:Integer;		begin			NoSelect:=False;			last.h:=0;			last.v:=0;			if LGetSelect(true,last,list) then				begin					len:=SizeOf(Particle);					LGetCell(pointer(ord(@Particle)),Len,Last,List);				end			else				NoSelect:=true;		end;     procedure SetParticle(	var Particle:ParticleType;     										var NoSelect:Boolean);		var			Last:Cell;		begin			NoSelect:=False;			last.h:=0;			last.v:=0;			if LGetSelect(true,last,list) then				LSetCell(pointer(ord(@Particle)),SizeOf(Particle),Last,List)			else				NoSelect:=true;		end;{******************************}	procedure CleanHeader;		var			i:integer;		begin			with Header do				begin					Event:=''; 					Date:=''; 					operator:=''; 					ZZO:=0; 					ShrinkFactZT:=0; 					ShrinkFactZM:=0; 					Magnification:=0; 					for i:=1 to 4 do 						begin 							X[i]:=0.0; 							y[i]:=0.0; 							z[i]:=0.0; 						end;					dipofprimary:=0; 					ShrinkFactAN:=0;				end;		end;{*****************************}	Procedure SetDlgStr(	DialogPointer	:DialogPtr;										Item				:integer;										TheString		:str255);		var			ItemType		:integer;			TextHandle		:Handle;			Box					:rect;		begin			GetDItem(DialogPointer,Item,ItemType,TextHandle,Box);			SetItext(TextHandle,TheString);		end;	procedure SetReal(	DialogPointer		:DialogPtr;										Item					:integer;										TheReal				:real);		var			ItemType		:integer;			TextHandle		:Handle;			Box					:rect;			TheString		:str255;		begin			GetDItem(DialogPointer,item,ItemType,TextHandle,Box);			RealToString(TheReal,TheString);			SetItext(TextHandle,TheString);		end;	function GetDlgStr(	DialogPointer	:DialogPtr;										Item				:integer):str255;		var			ItemType		:integer;			TextHandle		:Handle;			Box					:rect;			TheString		:str255;		begin			GetDItem(DialogPointer,Item,ItemType,TextHandle,Box);			GetItext(TextHandle,TheString);			GetDlgStr:=TheString;		end;	function GetReal(	DialogPointer		:DialogPtr;									Item					:integer):Real;		var			ItemType		:integer;			TextHandle		:Handle;			Box					:rect;			RealString		:str255;			TheReal			:real;		begin			GetDItem(DialogPointer,item,ItemType,TextHandle,Box);			GetItext(TextHandle,RealString);			StringToReal(RealString,TheReal);			GetReal:=TheReal;		end;{********************}	procedure ClearBuffer(var FootStop:Boolean);		var			ch:char;			Dummy:Longint;		begin			Delay(15,dummy);			FootStop:=False;			While InReady(SPortA) do				begin					GetChar(SPortA,ch);					if  ch = 'S' then						FootStop:=True;				end;		end;	procedure GetStringM(var TheString:str255);		var			ch:char;			i:integer;			A:integer;		begin			thestring:='';			repeat				begin					GetChar(SPortA,ch);					if  ch > chr(32) then						thestring:=concat(thestring,ch);				end;			until ch=chr(10);		end;	procedure SendString(TheString:str255);		var			i:integer;		begin			for i := 1 to Length(TheString) do				sendChar(SPortA,TheString[i]);			sendChar(SPortA,chr(13));			sendChar(SPortA,chr(10));		end;	procedure ReadMicro(var channel1,channel2,channel3:Real;						var	FootStop:Boolean);		var			TheString:str255;			Dummy:boolean;		begin			ClearBuffer(FootStop);			SendString('D1');			getStringM(TheString);			StringtoReal(TheString,channel1);			SendString('D2');			getStringM(TheString);			StringtoReal(TheString,channel2);			SendString('D3');			getStringM(TheString);			StringtoReal(TheString,channel3);			ClearBuffer(dummy);		end;{***********************}	Function Filter(TheDialog:DialogPtr;		var theEvent:EventRecord;		var itemNumber:Integer):			Boolean;		const			returnCode=				13;			enterCode=				3;			CancelCode=				27;		var			charCode:				char;		begin			Filter:=false;			if theEvent.What = keyDown then				begin					CharCode:=chr(BitAnd(theEvent.message,charCodeMask));					if BitAnd(theEvent.modifiers,CmdKey) = CmdKey then						begin							case CharCode of								'X':DlgCut(TheDialog);								'C':DlgCopy(TheDialog);								'V':DlgPaste(TheDialog);								'B':DlgDelete(TheDialog);							end;							Filter:=true;						end;					if CharCode = chr(returnCode) then						begin							itemNumber:=OK;							Filter:=true;						end;					if CharCode = chr(CancelCode) then						begin							itemNumber := Cancel;							Filter:=true;						end;					if CharCode = chr(enterCode) then						begin							theEvent.message:=theEvent.message+6;							Filter:=false;						end;				end;			if inReady(SPortA) then				begin					itemNumber:=99;					Filter:=True;				end;		end;	Procedure Modal(		var			cancel:				Boolean;		var			DialogPointer:				DialogPtr);		Var			itemHit:				integer;			Done:				boolean;			channel1,			channel2,			channel3:				Real;			footstop:				Boolean;  		begin  			cancel:=false;  			done:=false;        	repeat            	begin {repeat}               	ModalDialog(@Filter,itemHit);               	case itemHit of                 		1:Done:=true;                 		2:begin                     			done:=true;                      			cancel:=true;                    		end;                    	99:begin                    			ReadMicro(channel1,channel2,channel3,FootStop);								if FootStop then									done:=true;								SetReal(DialogPointer,4,channel1);								SetReal(DialogPointer,5,channel2);								SetReal(DialogPointer,6,channel3);								ClearBuffer(FootStop);							end;                	end;{case}              	end;{repeat}          	until done;    	end;{dialog}    procedure HeaderDialog(var cancel:boolean);		var			seconds:longint;			i:integer;			DialogPointer:DialogPtr;		begin			if Header.Date = '' then				begin					getdatetime(seconds);					IUDateString(seconds,shortDate,Header.Date);				end;			if Header.Event = '' then				begin				end;			if Header.Operator = '' then				begin				end;			DialogPointer:=GetNewDialog(HeaderRes,nil,pointer(-1));			SetDlgStr(DialogPointer,3,Header.Event);			SetDlgStr(DialogPointer,4,Header.Date);			SetDlgStr(DialogPointer,5,Header.Operator);			SetReal(DialogPointer,6,Header.ShrinkFactZT);			SetReal(DialogPointer,7,Header.ShrinkFactZM);			SetReal(DialogPointer,8,Header.Magnification);			SetReal(DialogPointer,9,Header.ZZO);			for i:=1 to 4 do				begin					SetReal(DialogPointer,10+(i-1)*3,Header.X[i]);					SetReal(DialogPointer,11+(i-1)*3,Header.Y[i]);					SetReal(DialogPointer,12+(i-1)*3,Header.Z[i]);				end;			SetReal(DialogPointer,22,Header.ShrinkFactAN);			SetReal(DialogPointer,23,Header.dipofprimary);			Modal(Cancel,DialogPointer);			if not cancel then				begin					Header.Event:=GetDlgStr(DialogPointer,3);					Header.Date:=GetDlgStr(DialogPointer,4);					Header.Operator:=GetDlgStr(DialogPointer,5);					Header.ShrinkFactZT:=GetReal(DialogPointer,6);					Header.ShrinkFactZM:=GetReal(DialogPointer,7);					Header.Magnification:=GetReal(DialogPointer,8);					Header.ZZO:=GetReal(DialogPointer,9);					for i:=1 to 4 do						begin							Header.X[i]:=GetReal(DialogPointer,10+(i-1)*3);							Header.Y[i]:=GetReal(DialogPointer,11+(i-1)*3);							Header.Z[i]:=GetReal(DialogPointer,12+(i-1)*3);						end;					CalcHeader(Header);				end;			CloseDialog(DialogPointer);		end;    procedure ParticleDialog(	var Particle		:ParticleType;    											var Cancel		:Boolean);		var			DialogPointer:DialogPtr;		begin			DialogPointer:=GetNewDialog(ParticleRes,nil,pointer(-1));			SetDlgStr(DialogPointer,3,Particle.Number);			SetReal(DialogPointer,4,Particle.Theta);			SetReal(DialogPointer,5,Particle.ZScaleDiv);			SetReal(DialogPointer,6,Particle.YMicrons);			SetReal(DialogPointer,7,Particle.GrainCount);			SetReal(DialogPointer,8,Particle.P);			SetReal(DialogPointer,9,Particle.L);			SetDlgStr(DialogPointer,10,Particle.fate);			SetReal(DialogPointer,11,Particle.Beta);			SetReal(DialogPointer,12,Particle.degrees);			SetReal(DialogPointer,13,Particle.azimuth);			SetReal(DialogPointer,14,Particle.azidegree);			SetReal(DialogPointer,15,Particle.pseudo);			SetReal(DialogPointer,16,Particle.dip);			SetReal(DialogPointer,17,Particle.X);			SetReal(DialogPointer,18,Particle.Y);			SetReal(DialogPointer,19,Particle.Z);			Modal(Cancel,DialogPointer);			if not cancel then				begin					Particle.Number:=GetDlgStr(DialogPointer,3);					Particle.Theta:=GetReal(DialogPointer,4);					Particle.ZScaleDiv:=GetReal(DialogPointer,5);					Particle.YMicrons:=GetReal(DialogPointer,6);					Particle.GrainCount:=GetReal(DialogPointer,7);					Particle.P:=GetReal(DialogPointer,8);					Particle.L:=GetReal(DialogPointer,9);					Particle.fate:=GetDlgStr(DialogPointer,10);					CalcParticle(particle,header);				end;			CloseDialog(DialogPointer);		end;{*******************}	procedure DebugDialog{(	theString:str255;    											theReal:Real;    											TheInteger:integer)};		var			cancel:boolean;			DialogPointer:DialogPtr;    	begin    		DialogPointer:=GetNewDialog(DebugRes,nil,pointer(-1));    		SetDlgStr(DialogPointer,3,TheString);			SetReal(DialogPointer,4,TheReal);			NumToString(TheInteger,TheString);			SetDlgStr(DialogPointer,5,TheString);    		Modal(Cancel,DialogPointer);			CloseDialog(DialogPointer);    	end;	procedure AreYouSure(	TheString	:Str255;											var cancel	:boolean);		var			DialogPointer:DialogPtr;		begin			DialogPointer:=GetNewDialog(AreSureRes,nil,pointer(-1));			SetDlgStr(DialogPointer,3,TheString);			Modal(Cancel,DialogPointer);			CloseDialog(DialogPointer);		end;{**********************}	procedure ProcessMenu(CodeWord : LongInt);		var			menuNum : Integer;			itemNum : Integer;{***********************}		procedure DoAppleMenu;			procedure About;				var					AboutRecord : DialogRecord;					AboutDlog : DialogPtr;					dummy:integer;				begin					AboutDlog := GetNewDialog(AboutRes,nil,Pointer(-1));					ModalDialog(nil,dummy);					CloseDialog(AboutDlog);				end;			procedure DeskAccesory;				var					dummy:integer;					nameHolder : str255;				begin					GetItem(myMenus[appleMenu],ItemNum,NameHolder);					dummy := OpenDeskAcc(NameHolder);				end;			begin				case ItemNum of					1:About;					2 :;					otherwise						deskAccesory;				end;			end;{*****************}		procedure DoEditMenu;			begin				if not SystemEdit(ItemNum - 1) then					begin						case ItemNum of						end;					end;			end;{*****************}		procedure DoFileMenu;			{procedures for file menu}			procedure NewList;				var					CSize:Point;					DataBounds,rview:Rect;				begin					if InMem then						begin							LDispose(List);							CloseWindow(listWindow);						end;					ListWindow:=GetNewWindow(300,nil,Pointer(-1));					SetPort(ListWindow);					Databounds.top:=0;					DataBounds.Left:=0;					DataBounds.Bottom:=0;					DataBounds.Right:=1;					Rview:=ListWindow^.PortRect;					Rview.right:=Rview.right-16;					CSize.v:=16;					CSize.h:=rview.right-rview.left;					list:=Lnew(Rview,databounds,cSize,0,Listwindow,false,false,false,true);					List^^.ListDefProc:=NewHandle(0);					List^^.ListDefProc^:=ptr(@MyListDef);					List^^.selFlags:=lOnlyOne;					LDoDraw(true,List);				end;			procedure FileError;				var					TheError:str255;					  				begin  					if IOR > 0 then  						begin  							GetErrorMessage(IOR,TheError);  							DebugDialog(TheError,IOR,0);  						end;  				end;			procedure ReadFile(Reply:SFReply);				var					f:filerec;					i:integer;					Particle:ParticleType;					Temp:Integer;				begin					FReset(f,reply.vRefNum,reply.fName);					FGetM(f,@Header,SizeOf(Header));					Header.Reply:=Reply;					Temp:=Header.NumParticle;					newlist;					Header.NumParticle:=0;					SetWTitle(ListWindow,Header.reply.fName);					for i := 1 to Temp do						begin							FGetM(f,@Particle,SizeOf(Particle));							AddParticle(Particle);						end;					FClose(f);					FileError;				end;			procedure WriteFile(Reply:SFReply);				var					f:FileRec;					Particle:ParticleType;					len:integer;					Last:Cell;					I:integer;				begin					FRewrite(f,reply.vRefNum,reply.fName,MicroKind,MicroCreator);					FPutM(f,@Header,SizeOf(Header));					len:=SizeOf(Particle);					last.h:=0;					SetWTitle(ListWindow,Header.reply.fName);					for i := 1 to Header.NumParticle do						begin							Last.v:=i-1;							LGetCell(pointer(ord(@Particle)),Len,Last,List);							FPutM(f,@Particle,SizeOf(Particle));						end;					FClose(f);					FileError;				end;			procedure GetReadFile(var reply:SFReply);				var					pt:point;					FileType:SFTypeList;				begin					pt.h:=50;					pt.v:=50;					FileType[0][1]:='D';					FileType[0][2]:='A';					FileType[0][3]:='T';					FileType[0][4]:='A';					SFGetFile(pt,'Enter File',nil,1,filetype,nil,reply);				end;			procedure GetWriteFile(var reply:SFReply);				var					pt:point;				begin					pt.h:=50;					pt.v:=50;					SFPutFile(pt,'Save File',Reply.Fname,nil,reply);				end;			{the File menu procedures}			procedure NewFile;				var					cancel:boolean;				begin					if changed and InMem then						AreYouSure('Are you sure you want to throw away Changes to this file?',Cancel);					if not cancel then						begin							CleanHeader;							HeaderDialog(Cancel);							NewList;							Header.Reply.FName:='untitled';							SetWTitle(ListWindow,Header.reply.fName);							Header.NumParticle:=0;							changed:=True;							InMem:=True;							FromFile:=False;						end;				end;			procedure OpenFile;				var					Cancel:Boolean;				begin					if inmem and Changed then						AreYouSure('Are you sure you want to throw away Changes to this file?',Cancel);					if not cancel then						begin							GetReadFile(Header.Reply);							if  Header.Reply.good then								begin									ReadFile(Header.Reply);									Changed:=True;									InMem:=True;									fromFile:=true;								end;						end;				end;			Procedure CloseFile;				var					cancel:Boolean;				begin					if Changed and inmem then						AreYouSure('Are you sure you want to throw away Changes to this file?',Cancel);					if not cancel then						begin							LDispose(List);							DisposeWindow(listWindow);							InMem:=False;							changed:=False;							FromFile:=False;						end;				end;			Procedure SaveAsFile;				begin					GetWriteFile(Header.Reply);					if Header.Reply.Good then						begin							WriteFile(Header.Reply);							Changed:=False;							FromFile:=true;						end;				end;			Procedure SaveFile;				begin					WriteFile(Header.Reply);					Changed:=False;					FromFile:=true;				end;			Procedure RevertFile;				var					cancel:Boolean;				begin					if Changed and inmem then						AreYouSure('Are you sure you want to throw away Changes to this file?',Cancel);					if not cancel then						begin							NewList;							ReadFile(Header.Reply);							Changed:=False;							InMem:=True;							fromFile:=true;						end;				end;			Procedure AppendFile;				begin				end;			Procedure PageSetUp;				var					trueORfalse : boolean;				begin  					trueORfalse := PrValidate(PgSetUp);					trueORfalse := PrStlDialog(PgSetUp);				end;			Procedure PrintFile;				var					PrintPort:TPPrPort;				begin				end;			Procedure QuitProgram;							var					cancel:Boolean;				begin					if Changed and inmem then						AreYouSure('Are you sure you want to throw away Changes to this file?',Cancel);					if not cancel then						Done:=True;				end;			begin				case ItemNum of					1:NewFile;					2:OpenFile;					3:CloseFile;					4:;					5:SaveFile;					6:SaveAsFile;					7:RevertFile;					8:;					9:AppendFile;					10:;					11:PageSetUp;					12:PrintFile;					13:;					14:QuitProgram;				end;				DrawMenu;			end;{******************}		procedure DoParticleMenu;			procedure NewParticle(var Cancel:Boolean);				var					particle:ParticleType;				begin					CleanParticle(Particle);					ParticleDialog(Particle,cancel);					if not cancel then						begin							AddParticle(Particle);							Changed:=true;						end;				end;			procedure AddParticleMenu;				var					cancel:boolean;				begin					NewParticle(Cancel);				end;			procedure AddContinuousParticle;				var					cancel:boolean;				begin					repeat						NewParticle(Cancel);					until cancel;				end;			procedure EditParticle;				var					cancel,NoSelect:boolean;					Particle:ParticleType;				begin					GetParticle(Particle,NoSelect);					if not NoSelect then						begin							ParticleDialog(Particle,cancel);							if not cancel then								begin									SetParticle(Particle,NoSelect);									Changed:=true;								end;						end;				end;			procedure ClearParticle;				var					particle:ParticleType;					NoSelect:Boolean;				begin					GetParticle(Particle,NoSelect);					if not NoSelect then						begin							CleanParticle(Particle);							SetParticle(Particle,NoSelect);							Changed:=true;						end;				end;			procedure DeleteParticleMenu;				var					noSelect:Boolean;				begin					DeleteParticle(NoSelect);					if Not NoSelect then						changed:=true;				end;			begin				case ItemNum of					1:AddParticleMenu;					2:AddContinuousParticle;					3:EditParticle;					4:ClearParticle;					5:DeleteParticleMenu;				end;				DrawMenu;			end;{****************}		procedure DoHeaderMenu;			procedure EditHeader;				var					cancel:boolean;				begin					HeaderDialog(Cancel);					if not cancel then						Changed:=true;				end;			Procedure ClearHeader;				begin					CleanHeader;					changed:=true;				end;			begin				case ItemNum of					1:EditHeader;					2:ClearHeader;				end;				DrawMenu;			end;{*****************}		begin			menuNum := HiWord(CodeWord);			itemNum := LoWord(CodeWord);			if itemNum > 0 then				begin					case MenuNum of						1:DoAppleMenu;						2:DoFileMenu;						3:DoEditMenu;						4:DoParticleMenu;						5:DoHeaderMenu;					end;				end;			HiliteMenu(0);		end;{******************}	procedure AllDone;		begin			CloseSPort(sPortA);		end;{******************}	procedure MainEventLoop;		var			Event : EventRecord;			windowLoc : integer;			mouseLoc : point;			theWindow:WindowPtr;			trickVar : trickType;			CharCode : Char;			aBool : Boolean;			totalRect : Rect;			Last:Cell;		begin			repeat				SystemTask;				if InMem then					begin						Last.v:=0;						Last.h:=0;						if not LGetSelect(true,Last,List) then							begin								Last.v:=0;								Last.h:=0;								LSetSelect(True,last,List);							end;					end;				if GetNextEvent(everyEvent,Event) then					begin						case event.what of							mouseDown :								begin									mouseLoc := Event.where;									windowLoc := FindWindow(mouseLoc,theWindow);									case windowLoc of										inMenuBar :											ProcessMenu(MenuSelect(MouseLoc));										inSysWindow:											SystemClick(Event,theWindow);										inContent:											begin												GlobalToLocal(MouseLoc);												aBool := LClick(MouseLoc, Event.modifiers,List);											end;										inDrag:											begin        										DragWindow(theWindow,mouseLoc,DragArea);												SelectWindow(theWindow);      										end;      									inGrow:      										begin      											GlobalToLocal(MouseLoc);												aBool := LClick(MouseLoc, Event.modifiers,List);      										end;      									inGoAway:      										begin      										end;      									inDesk:      										Begin      										end;									end;								end;							UpdateEvt :								begin									BeginUpdate(ListWindow);									List^^.listdefProc^ := Ptr(@MyListDef);									LUpdate(ListWindow^.visRgn,List);									EndUpdate(ListWindow);								end;							ActivateEvt :								begin									LActivate(Odd(Event.modifiers),List);									InvalRect(ListWindow^.PortRect);								end;							keyDown,AutoKey :								begin									trickVar.I := Event.Message;									CharCode := trickVar.chr0;									if BitAnd(Event.modifiers,CmdKey) = CmdKey then										ProcessMenu(MenuKey(CharCode));								end;						end;					end;			until Done;		end;{**************************}	procedure InitThings;		procedure SetupLimits;			var				Screen : Rect;			begin				Screen := ScreenBits.bounds;				with Screen do					begin						SetRect(DragArea,left+4,top+24,right-4,bottom-4);						SetRect(GrowArea,left,top+24,right,bottom);					end;			end;		procedure SetUpMenus;				var					index : integer;			begin				for index := beginMenu to endMenu do					myMenus[index] := GetMenu(index);				AddResMenu(myMenus[appleMenu],'DRVR');				for index := beginMenu to endMenu do					InsertMenu(myMenus[index],0);				DrawMenu;			end;		procedure SetUpPort;			var				Dummy:integer;			begin				Dummy:=InitSPort(SPortA,baud2400,stop10,noParity,data7,1000,xOnXOff,xOnXOff);				SendString('SON');				SetBufSize(1000);			end;		procedure SetupMemory;			var				x : Longint;			begin				x := ORD4(ApplicZone) + 256000;				SetApplLimit(Pointer(x));				MaxApplZone;				MoreMasters;				MoreMasters;				MoreMasters;				MoreMasters;				MoreMasters;				MoreMasters;			end;		begin			Done:=False;			InMem:=False;			Changed:=False;			FromFile:=False;			FlushEvents(everyEvent,0);			InitGraf(@thePort);			InitFonts;			InitWindows;			InitMenus;			TEInit;			InitDialogs(nil);			InitCursor;			InitAllPacks;			SetupLimits;			SetUpMemory;			SetUpMenus;			SetUpPort;		end;{***********************}	begin		initThings;		MainEventLoop;		AllDone;	end.